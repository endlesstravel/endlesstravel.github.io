<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Love2dCS</name>
    </assembly>
    <members>
        <member name="T:Love.Misc.Moonshine.Moonshine">
            <summary>
            Postprocessing effect repository for LÖVE.
            <para> adapt from https://github.com/vrld/moonshine .</para>
            <para> more resource https://www.love2d.org/forums/viewtopic.php?t=3733 .</para>
            </summary>
        </member>
        <member name="P:Love.Misc.Moonshine.Moonshine.Effect.Enable">
            <summary>
            this effect is enabled
            </summary>
        </member>
        <member name="F:Love.Misc.Moonshine.Moonshine.DoubleBufferCanvas.Front">
            <summary>
            The destination it should render into.
            </summary>
        </member>
        <member name="F:Love.Misc.Moonshine.Moonshine.DoubleBufferCanvas.Back">
            <summary>
            The previous result
            </summary>
        </member>
        <member name="M:Love.Misc.Moonshine.Moonshine.DoubleBufferCanvas.Swap">
            <summary>
            Swap Front and Back. (Back, Front = Front, Back)
            </summary>
        </member>
        <member name="M:Love.Misc.Moonshine.Moonshine.DoubleBufferCanvas.Swap(Love.Shader)">
            <summary>
            Swap Front and Back with shader. (Back, Front = Front, Back)
            </summary>
        </member>
        <member name="M:Love.Misc.Moonshine.Moonshine.DrawWithShader(Love.Canvas,Love.Canvas,Love.Shader)">
            <summary>
            this function uses shader to draw the Source buffer to the Dest buffer with given Shader.
            </summary>
            <param name="dest">Canvas that ready to draw as target</param>
            <param name="source">Canvas to draw</param>
            <param name="shader">Shader used when draw source canvas to dest canvas</param>
        </member>
        <member name="M:Love.Misc.Moonshine.Moonshine.China(Love.Misc.Moonshine.Moonshine.Effect)">
            <summary>
            Create MoonShine
            </summary>
            <param name="w"></param>
            <param name="h"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Misc.Moonshine.Moonshine.Create(System.Int32,System.Int32,Love.Misc.Moonshine.Moonshine.Effect)">
            <summary>
            Create MoonShine With width and height
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:Love.Misc.Moonshine.Moonshine.BoxBlur">
            <summary>
             simple blurring
            </summary>
        </member>
        <member name="F:Love.Misc.Moonshine.Moonshine.BoxBlur.Default">
            <summary>
            default BoxBlur
            </summary>
        </member>
        <member name="M:Love.Misc.Moonshine.Moonshine.BoxBlur.#ctor">
            <summary>
            default BoxBlur constructor
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Moonshine.Chromasep">
            <summary>
            cheap/fake chromatic aberration
            </summary>
        </member>
        <member name="F:Love.Misc.Moonshine.Moonshine.Chromasep.Default">
            <summary>
            Default Effect
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Moonshine.ColorGradeSimple">
            <summary>
            weighting of color channels
            </summary>
        </member>
        <member name="F:Love.Misc.Moonshine.Moonshine.ColorGradeSimple.Default">
            <summary>
            Default Effect
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Moonshine.CRT">
            <summary>
            crt/barrel distortion
            </summary>
        </member>
        <member name="F:Love.Misc.Moonshine.Moonshine.CRT.Default">
            <summary>
            Default Effect
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Moonshine.Desaturate">
            <summary>
            desaturation and tinting
            </summary>
        </member>
        <member name="F:Love.Misc.Moonshine.Moonshine.Desaturate.Default">
            <summary>
            Default Effect
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Moonshine.DMG">
            <summary>
            Gameboy and other four color palettes
            </summary>
        </member>
        <member name="F:Love.Misc.Moonshine.Moonshine.DMG.GameBoyPalette.Default">
            <summary>
            Default color palette. Source: http://en.wikipedia.org/wiki/List_of_video_game_console_palettes#Original_Game_Boy
            </summary>
        </member>
        <member name="F:Love.Misc.Moonshine.Moonshine.DMG.GameBoyPalette.DarkYellow">
            <summary>
            Hardcore color profiles. Source: http://www.hardcoregaming101.net/gbdebate/gbcolours.htm
            </summary>
        </member>
        <member name="F:Love.Misc.Moonshine.Moonshine.DMG.Default">
            <summary>
            Default Effect
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Moonshine.FastGaussianBlur">
            <summary>
            faster Gaussian blurring
            <para>Bilinear Gaussian blur filter as detailed here: http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/</para>
            <para>Produces near identical results to a standard Gaussian blur by using sub-pixel sampling, this allows us to do ~1/2 the number of pixel lookups.</para>
            <para>unroll convolution loop</para>
            </summary>
        </member>
        <member name="P:Love.Misc.Moonshine.Moonshine.FastGaussianBlur.Taps">
            <summary>
            Number of effective samples to take per pass. e.g. 3-tap is the current pixel and the neighbors each side.
            <para>More taps = larger blur, but slower.</para>
            </summary>
        </member>
        <member name="P:Love.Misc.Moonshine.Moonshine.FastGaussianBlur.Offset">
            <summary>
            <para>Offset of each tap.</para>
            <para>For highest quality this should be &lt;= 1 but if the image has low entropy we can approximate the blur with a number &gt; 1 and less taps, for better performance.</para>
            </summary>
        </member>
        <member name="P:Love.Misc.Moonshine.Moonshine.FastGaussianBlur.Type">
            <summary>
            <para>Offset type, either 'weighted' or 'center'.</para>
            <para>'weighted' gives a more accurate gaussian decay but can introduce modulation for high frequency details.</para>
            </summary>
        </member>
        <member name="P:Love.Misc.Moonshine.Moonshine.FastGaussianBlur.Sigma">
            <summary>
            <para>Sigma value for gaussian distribution. You don't normally need to set this.</para>
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Moonshine.FilmGrain">
            <summary>
            image noise
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Moonshine.GaussianBlur">
            <summary>
            gaussian blur
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Moonshine.Glow">
            <summary>
            aka (light bloom)
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Moonshine.Godsray">
            <summary>
            aka light scattering
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Moonshine.Pixelate">
            <summary>
            sub-sampling (for that indie look)
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Moonshine.Posterize">
            <summary>
            restrict number of colors
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Moonshine.Scanlines">
            <summary>
            horizontal lines
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Moonshine.Sketch">
            <summary>
            simulate pencil drawings
            </summary>
        </member>
        <member name="T:Love.Misc.Moonshine.Moonshine.Vignette">
            <summary>
            shadow in the corners
            </summary>
        </member>
        <member name="T:Love.Misc.QuadTree.QuadrantEnum">
            <summary>
            一个矩形区域的象限划分：
            0---------------------------> x
            |                   |
            |        leftTop(0) | rightTopNode(1)
            |  -----------------|---------
            | leftBottomNode(2) | RightBottomNode(3)
            |                   |
            | 
            \/ y
            以下对该象限类型的枚举
            </summary>
        </member>
        <member name="M:Love.Misc.QuadTree.QuadTreeNode.Insert(Love.Misc.QuadTree.Leaf,System.Single)">
            <summary>
            尝试插入 item 到此节点或者其子节点中，当 item 大于此区域插入失败
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Love.Misc.QuadTree.QuadTreeNode.QueryArea(Love.RectangleF)">
            <summary>
            当此节点不在所给 RectangleF 时返回 null
            </summary>
            <param name="rect"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Misc.QuadTree.QuadTreeNode.Remove(Love.Misc.QuadTree.Leaf)">
            <summary>
            尝试从此节点里删除一个 item
            当item不被此节点区域包含时删除失败
            当集合里没有此 item 时也将删除失败
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:Love.Misc.QuadTree.QuadTree">
            <summary>
            RectangleF based Quad tree
            </summary>
        </member>
        <member name="F:Love.Misc.QuadTree.QuadTree.m_root">
            <summary>
            root node
            </summary>
        </member>
        <member name="F:Love.Misc.QuadTree.QuadTree.overFlowLeaf">
            <summary>
            left that out of word
            </summary>
        </member>
        <member name="M:Love.Misc.QuadTree.QuadTree.Add(Love.Misc.QuadTree.Leaf)">
            <summary>
            插入到四叉树中
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Misc.QuadTree.QuadTree.QueryArea(Love.RectangleF)">
            <summary>
            区域查询
            </summary>
            <param name="rect"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Misc.QuadTree.QuadTree.Remove(Love.Misc.QuadTree.Leaf)">
            <summary>
            移除一个节点
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Misc.QuadTree.QuadTree.Traverse(System.Action{Love.RectangleF,System.Collections.Generic.IEnumerable{Love.Misc.QuadTree.Leaf}})">
            <summary>
            便利所有节点
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Love.Misc.QuadTree.QuadTree.DrawDebug">
            <summary>
            绘制 Debug 信息
            </summary>
        </member>
        <member name="T:Love.Event">
            <summary>
            <para>Manages events, like keypresses.</para>
            </summary>
        </member>
        <member name="M:Love.Event.Poll(Love.Scene)">
            <summary>
            Returns an iterator for messages in the event queue.
            </summary>
            <param name="scene">event handler</param>
            <returns></returns>
        </member>
        <member name="M:Love.Event.Wait(Love.Scene)">
            <summary>
            Like <see cref="M:Love.Event.Poll(Love.Scene)"/>, but blocks until there is an event in the queue.	
            </summary>
            <param name="scene">event handler</param>
            <returns></returns>
        </member>
        <member name="M:Love.Event.Quit(System.Int32)">
            <summary>
            Exits the LÖVE program.
            <para>Adds the quit event to the queue.</para>
            <para>The quit event is a signal for the event handler to close LÖVE. It's possible to abort the exit process with the love.quit callback.</para>
            </summary>
            <param name="exitStatus">The program exit status to use when closing the application.</param>
        </member>
        <member name="M:Love.Event.PollOrWait(Love.Scene,System.Boolean)">
            <summary>
            poll or wait a event
            </summary>
            <param name="poll_or_wait">True: poll; False: wait</param>
            <returns></returns>
        </member>
        <member name="T:Love.Window">
            <summary>
            <para>用于修改窗口和获取窗口信息。</para>
            <para>Provides an interface for modifying and retrieving information about the program's window.</para>
            </summary>
        </member>
        <member name="M:Love.Window.SetFullscreen(System.Boolean)">
            <summary>
            Enters or exits fullscreen. The display to use when entering fullscreen is chosen based on which display the window is currently in, if multiple monitors are connected.
            </summary>
            <param name="fullscreen">Whether to enter or exit fullscreen mode.</param>
            <returns>True if an attempt to enter fullscreen was successful, false otherwise.</returns>
        </member>
        <member name="M:Love.Window.GetFullscreen">
            <summary>
            Gets whether the window is fullscreen.
            </summary>
            <returns>True if the window is fullscreen, false otherwise.</returns>
        </member>
        <member name="M:Love.Window.GetDisplayCount">
            <summary>
            <para>获取当前显示器的数量。</para>
            Gets the number of connected monitors.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Window.GetDisplayName(System.Int32)">
            <summary>
            <para>获取显示器的名称。</para>
            <para>Gets the name of a display.</para>
            </summary>
            <param name="displayindex"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Window.SetMode(System.Int32,System.Int32,Love.WindowSettings)">
            <summary>
            <para>设置窗口的显示模式和属性。</para>
            <para>如果width或height为0，则setMode将使用桌面的宽度和高度。</para>
            <para>更改显示模式可能会产生副作用：例如，将清除 Canvas 并使用Shader：send发送到着色器的值将被删除。 如果需要，请务必事先保存 Canvas 的内容或之后重新绘制。</para>
            <para>Sets the display mode and properties of the window.</para>
            <para>If width or height is 0, setMode will use the width and height of the desktop.</para>
            <para>Changing the display mode may have side effects: for example, canvases will be cleared and values sent to shaders with Shader:send will be erased. Make sure to save the contents of canvases beforehand or re-draw to them afterward if you need to.</para>
            </summary>
            <param name="width">Display width.</param>
            <param name="height">Display height.</param>
            <param name="flag"></param>
        </member>
        <member name="M:Love.Window.SetMode(Love.WindowSettings)">
            <summary>
            <para>设置窗口的显示模式和属性。</para>
            <para>如果width或height为0，则setMode将使用桌面的宽度和高度。</para>
            <para>更改显示模式可能会产生副作用：例如，将清除 Canvas 并使用Shader：send发送到着色器的值将被删除。 如果需要，请务必事先保存 Canvas 的内容或之后重新绘制。</para>
            <para>Sets the display mode and properties of the window.</para>
            <para>If width or height is 0, setMode will use the width and height of the desktop.</para>
            <para>Changing the display mode may have side effects: for example, canvases will be cleared and values sent to shaders with Shader:send will be erased. Make sure to save the contents of canvases beforehand or re-draw to them afterward if you need to.</para>
            </summary>
            <param name="flag"></param>
        </member>
        <member name="M:Love.Window.GetMode">
            <summary>
            Gets the display mode and properties of the window.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Window.GetMode(System.Int32@,System.Int32@)">
            <summary>
            Gets the display mode and properties of the window.
            </summary>
            <param name="out_width">Window width.</param>
            <param name="out_height">Window height.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Window.GetFullscreenModes(System.Int32)">
            <summary>
            Gets a list of supported fullscreen modes.
            </summary>
            <param name="displayindex">The index of the display, if multiple monitors are available.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Window.SetFullscreen(System.Boolean,Love.FullscreenType)">
            <summary>
            Enters or exits fullscreen. The display to use when entering fullscreen is chosen based on which display the window is currently in, if multiple monitors are connected.
            </summary>
            <param name="fullscreen">Whether to enter or exit fullscreen mode.</param>
            <param name="fstype">The type of fullscreen mode to use.</param>
            <returns>True if an attempt to enter fullscreen was successful, false otherwise.</returns>
        </member>
        <member name="M:Love.Window.GetFullscreen(System.Boolean@,Love.FullscreenType@)">
            <summary>
            Gets whether the window is fullscreen.
            </summary>
            <param name="out_fullscreen">True if the window is fullscreen, false otherwise.</param>
            <param name="out_fstype">The type of fullscreen mode used.</param>
        </member>
        <member name="M:Love.Window.IsOpen">
            <summary>
            True if the window is open, false otherwise.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Window.Close">
            <summary>
            Closes the window. It can be reopened with love.window.setMode.
            <para>love.graphics functions and objects will cause a hard crash of LÖVE if used while the window is closed.</para>
            </summary>
        </member>
        <member name="M:Love.Window.GetDesktopDimensions(System.Int32)">
            <summary>
            Gets the width and height of the desktop.
            </summary>
            <param name="displayIndex">The index of the display, if multiple monitors are available.</param>
        </member>
        <member name="M:Love.Window.SetPosition(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the position of the window on the screen.
            </summary>
            <param name="x">The x-coordinate of the window's position.</param>
            <param name="y">The y-coordinate of the window's position.</param>
            <param name="displayindex">The window position is in the coordinate space of the specified display.</param>
        </member>
        <member name="M:Love.Window.GetPosition">
            <summary>
            Gets the position of the window on the screen
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Window.GetPosition(System.Int32@)">
            <summary>
            Gets the position of the window on the screen.
            And the index of the display that the window is in.
            </summary>
            <param name="out_displayindex"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Window.SetIcon(Love.ImageData)">
            <summary>
            Sets the window icon until the game is quit. Not all operating systems support very large icon images.
            </summary>
            <param name="imagedata">The window icon image.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Window.GetIcon">
            <summary>
            The window icon imagedata, or nil if no icon has been set with love.window.setIcon.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Window.SetDisplaySleepEnabled(System.Boolean)">
            <summary>
            Sets whether the display is allowed to sleep while the program is running.
            <para>Display sleep is disabled by default. Some types of input(e.g.joystick button presses) might not prevent the display from sleeping, if display sleep is allowed.</para>        
            </summary>
            <param name="enable">True to enable system display sleep, false to disable it.</param>
        </member>
        <member name="M:Love.Window.IsDisplaySleepEnabled">
            <summary>
            Gets whether the display is allowed to sleep while the program is running.
            <para>Display sleep is disabled by default. Some types of input (e.g. joystick button presses) might not prevent the display from sleeping, if display sleep is allowed.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Window.SetTitle(System.Byte[])">
            <summary>
            Sets the window title. (UTF-8 byte array version)
            <para>Constantly updating the window title can lead to issues on some systems and therefore is discouraged.</para>
            </summary>
            <param name="titleStr">The new window title.(UTF-8 byte array)</param>
        </member>
        <member name="M:Love.Window.GetTitle">
            <summary>
            Gets the window title.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Window.HasFocus">
            <summary>
            Checks if the game window has keyboard focus.
            </summary>
            <returns>True if the window has the focus or false if not.</returns>
        </member>
        <member name="M:Love.Window.HasMouseFocus">
            <summary>
            Checks if the game window has mouse focus.
            </summary>
            <returns>True if the window has mouse focus or false if not.</returns>
        </member>
        <member name="M:Love.Window.IsVisible">
            <summary>
            Checks if the game window is visible.
            <para>The window is considered visible if it's not minimized and the program isn't hidden.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Window.GetDPIScale">
            <summary>
            <para>Gets the DPI scale factor associated with the window.</para>
            <para>The pixel density inside the window might be greater (or smaller) than the "size" of the window. For example on a retina screen in Mac OS X with the highdpi window flag enabled, the window may take up the same physical size as an 800x600 window, but the area inside the window uses 1600x1200 pixels. love.window.getDPIScale() would return 2.0 in that case.</para>
            <para>The love.window.fromPixels and love.window.toPixels functions can also be used to convert between units.</para>
            <para>The highdpi window flag must be enabled to use the full pixel density of a Retina screen on Mac OS X and iOS. The flag currently does nothing on Windows and Linux, and on Android it is effectively always enabled.</para>
            </summary>
            <returns>The pixel scale factor associated with the window.</returns>
        </member>
        <member name="M:Love.Window.ToPixels(System.Double)">
            <summary>
            <para>Converts a number from density-independent units to pixels.</para>
            <para>The pixel density inside the window might be greater (or smaller) than the "size" of the window. For example on a retina screen in Mac OS X with the highdpi window flag enabled, the window may take up the same physical size as an 800x600 window, but the area inside the window uses 1600x1200 pixels. love.window.getDPIScale() would return 2.0 in that case.</para>
            <para>The love.window.fromPixels and love.window.toPixels functions can also be used to convert between units.</para>
            <para>The highdpi window flag must be enabled to use the full pixel density of a Retina screen on Mac OS X and iOS. The flag currently does nothing on Windows and Linux, and on Android it is effectively always enabled.</para>
            <para>Most LÖVE functions return values and expect arguments in terms of pixels rather than density-independent units.</para>
            </summary>
            <param name="value">A number in density-independent units to convert to pixels.</param>
            <returns>The converted number, in pixels.</returns>
        </member>
        <member name="M:Love.Window.FromPixels(System.Double)">
            <summary>
            <para>Converts a number from pixels to density-independent units.</para>
            <para>The pixel density inside the window might be greater (or smaller) than the "size" of the window. For example on a retina screen in Mac OS X with the highdpi window flag enabled, the window may take up the same physical size as an 800x600 window, but the area inside the window uses 1600x1200 pixels. love.window.getDPIScale() would return 2.0 in that case.</para>
            <para>The love.window.fromPixels and love.window.toPixels functions can also be used to convert between units.</para>
            <para>The highdpi window flag must be enabled to use the full pixel density of a Retina screen on Mac OS X and iOS. The flag currently does nothing on Windows and Linux, and on Android it is effectively always enabled.</para>
            <para>Most LÖVE functions return values and expect arguments in terms of pixels rather than density-independent units.</para>
            </summary>
            <param name="pixelvalue">A number in pixels to convert to density-independent units.</param>
            <returns>The converted number, in density-independent units.</returns>
        </member>
        <member name="M:Love.Window.Minimize">
            <summary>
            <para>Minimizes the window to the system's task bar / dock.</para>
            </summary>
        </member>
        <member name="M:Love.Window.Maximize">
            <summary>
            <para>Makes the window as large as possible.</para>
            <para>This function has no effect if the window isn't resizable, since it essentially programmatically presses the window's "maximize" button.</para>
            </summary>
        </member>
        <member name="M:Love.Window.IsMaximized">
            <summary>
            <para>Gets whether the Window is currently maximized.</para>
            <para>The window can be maximized if it is not fullscreen and is resizable, and either the user has pressed the window's Maximize button or love.window.maximize has been called.</para>
            </summary>
            <returns>True if the window is currently maximized in windowed mode, false otherwise.</returns>
        </member>
        <member name="M:Love.Window.ShowMessageBox(System.Byte[],System.Byte[],Love.MessageBoxType,System.Boolean)">
            <summary>
            Displays a simple message box with a single 'OK' button. (UTF-8 byte array version)
            <para>	This function will pause all execution of the main thread until the user has clicked a button to exit the message box. Calling the function from a different thread may cause love to crash.</para>
            </summary>
            <param name="title">The title of the message box. (UTF-8 byte array)</param>
            <param name="message">The text inside the message box. (UTF-8 byte array)</param>
            <param name="msgbox_type">The type of the message box.</param>
            <param name="attachToWindow">Whether the message box should be attached to the love window or free-floating.</param>
            <returns>Whether the message box was successfully displayed.</returns>
        </member>
        <member name="M:Love.Window.ShowMessageBox(System.String,System.String,System.String[],System.Int32,System.Int32,Love.MessageBoxType,System.Boolean)">
            <summary>
            Displays a message box with a customized list of buttons.
            <para>	This function will pause all execution of the main thread until the user has clicked a button to exit the message box. Calling the function from a different thread may cause love to crash.</para>
            </summary>
            <param name="title">The title of the message box.</param>
            <param name="message">The text inside the message box.</param>
            <param name="buttonName"></param>
            <param name="enterButtonIndex"> when the user presses 'enter', which button index should be return </param>
            <param name="escapebuttonIndex"> when the user presses 'escapeb', which button index should be return </param>
            <param name="msgbox_type">The type of the message box.</param>
            <param name="attachToWindow">Whether the message box should be attached to the love window or free-floating.</param>
            <returns>The index of the button pressed by the user. May be 0 if the message box dialog was closed without pressing a button.</returns>
        </member>
        <member name="M:Love.Window.RequestAttention(System.Boolean)">
            <summary>
            Causes the window to request the attention of the user if it is not in the foreground.
            <para>In Windows the taskbar icon will flash, and in OS X the dock icon will bounce.</para>
            </summary>
            <param name="continuous"></param>
        </member>
        <member name="M:Love.Window.SetTitle(System.String)">
            <summary>
            Sets the window title.
            <para>Constantly updating the window title can lead to issues on some systems and therefore is discouraged.</para>
            </summary>
            <param name="titleStr">The new window title.</param>
        </member>
        <member name="M:Love.Window.ShowMessageBox(System.String,System.String,Love.MessageBoxType,System.Boolean)">
            <summary>
            Displays a simple message box with a single 'OK' button.
            <para>	This function will pause all execution of the main thread until the user has clicked a button to exit the message box. Calling the function from a different thread may cause love to crash.</para>
            </summary>
            <param name="title">The title of the message box.</param>
            <param name="message">The text inside the message box.</param>
            <param name="msgbox_type">The type of the message box.</param>
            <param name="attachToWindow">Whether the message box should be attached to the love window or free-floating.</param>
            <returns>Whether the message box was successfully displayed.</returns>
        </member>
        <member name="T:Love.FileSystem">
            <summary>
            <para>Provides an interface to the user's filesystem.</para>
            <para>This module provides access to files in specific places:</para>
            <para>1. The root folder of the source directory archive / 2. The root folder of the game's save directory.</para>
            <para>Files that are opened for write or append will always be created in the save directory. The same goes for other operations that involve writing to the filesystem, like <see cref="M:Love.FileSystem.CreateDirectory(System.Byte[])"/>.</para>
            <para>It is recommended to set your game's identity first.  You can set it with <see cref="M:Love.FileSystem.SetIdentity(System.Byte[],System.Boolean)"/> as well.</para>
            </summary>
        </member>
        <member name="M:Love.FileSystem.NewFileData(System.String)">
            <summary>
            Creates a new FileData from a file on the storage device.
            </summary>
            <param name="filename">Path to the file.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.NewFile(System.Byte[],Love.FileMode)">
            <summary>
            Creates a new File object. It needs to be opened before it can be accessed. (UTF-8 byte array version)
            </summary>
            <param name="filename">The filename of the file.(UTF-8 byte array needed)</param>
            <param name="fmode_type">The mode to open the file in.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.NewFileData(System.Byte[],System.Byte[])">
            <summary>
            Creates a new FileData object.
            </summary>
            <param name="contents">The contents of the file.</param>
            <param name="filename">The name of the file.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.NewFileData(Love.File)">
            <summary>
            Creates a new FileData object.
            </summary>
            <param name="file">The file.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.Init(System.Byte[])">
            <summary>
            Initializes FileSystem, will be called internally, so should not be used explictly.
            </summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.IsFused">
            <summary>
            <para>Gets whether the game is in fused mode or not.</para>
            <para>If a game is in fused mode, its save directory will be directly in the Appdata directory instead of Appdata/LOVE/. The game will also be able to load C Lua dynamic libraries which are located in the save directory.</para>
            <para>A game is in fused mode if the source .love has been fused to the executable (see Game Distribution), or if "--fused" has been given as a command-line argument when starting the game.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.SetIdentity(System.Byte[],System.Boolean)">
            <summary>
            Sets the write directory for your game. Note that you can only set the name of the folder to store your files in, not the location.
            </summary>
            <param name="path">The new identity that will be used as write directory.(UTF-8 byte array needed)</param>
            <param name="append">Whether the identity directory will be searched when reading a filepath before or after the game's source directory and any currently.
            TRUE: results in searching source before searching save directory; FALSE: results in searching game save directory before searching source directorymounted archives.</param>
        </member>
        <member name="M:Love.FileSystem.GetIdentity">
            <summary>
            Gets the write directory name for your game. Note that this only returns the name of the folder to store your files in, not the full path.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.SetSource(System.Byte[])">
            <summary>
            Sets the source of the game, where the code is present. This function can only be called once, and is normally automatically done by LÖVE.
            </summary>
            <param name="path">Absolute path to the game's source folder.(UTF-8 byte array needed)</param>
        </member>
        <member name="M:Love.FileSystem.GetSource">
            <summary>
            <para>initially it was .exe folder </para>
            lua version: Returns the full path to the the .love file or directory. If the game is fused to the LÖVE executable, then the executable is returned.
            </summary>
            <returns>The full platform-dependent path of the .love file or directory.</returns>
        </member>
        <member name="M:Love.FileSystem.Mount(System.Byte[],System.Byte[],System.Boolean)">
            <summary>
            Mounts a zip file or folder in the game's save directory for reading. It is also possible to mount love.filesystem.getSourceBaseDirectory if the game is in fused mode.
            </summary>
            <param name="archive">The folder or zip file in the game's save directory to mount.(UTF-8 byte array needed)</param>
            <param name="mountpoint">The new path the archive will be mounted to.(UTF-8 byte array needed)</param>
            <param name="appendToPath">Whether the archive will be searched when reading a filepath before or after already-mounted archives. This includes the game's source and save directories.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.Unmount(System.Byte[])">
            <summary>
            Unmounts a zip file or folder previously mounted for reading with <see cref="M:Love.FileSystem.Mount(System.Byte[],System.Byte[],System.Boolean)"/>.
            </summary>
            <param name="archive">The folder or zip file in the game's save directory which is currently mounted.</param>
            <returns>True if the archive was successfully unmounted, false otherwise.</returns>
        </member>
        <member name="M:Love.FileSystem.GetWorkingDirectory">
            <summary>
            Gets the current working directory.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.GetUserDirectory">
            <summary>
            Returns the path of the user's directory
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.GetAppdataDirectory">
            <summary>
            Returns the application data directory (could be the same as getUserDirectory
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.GetSaveDirectory">
            <summary>
            Gets the full path to the designated save directory. This can be useful if you want to use the standard io library (or something else) to read or write in the save directory.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.GetRealDirectory(System.Byte[])">
            <summary>
            <para>Gets the platform-specific absolute path of the directory containing a filepath.</para>
            </summary>
            <param name="filename">The filepath to get the directory of.(UTF-8 byte array needed)</param>
            <returns>The platform-specific full path of the directory containing the filepath.</returns>
        </member>
        <member name="M:Love.FileSystem.GetExecutablePath">
            <summary>
            will be called internally, so should not be used explictly.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.GetInfo(System.Byte[])">
            <summary>
            Gets information about the specified file or directory.
            </summary>
            <param name="path">The file or directory path to check.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.CreateDirectory(System.Byte[])">
            <summary>
            <para>Recursively creates a directory.</para>
            <para>When called with "a/b" it creates both "a" and "a/b", if they don't exist already.</para>
            </summary>
            <param name="name">The directory to create. (UTF-8 byte array needed)</param>
            <returns>True if the directory was created, false if not.</returns>
        </member>
        <member name="M:Love.FileSystem.Remove(System.Byte[])">
            <summary>
            Removes a file or empty directory.
            </summary>
            <param name="path">The file or directory to remove.</param>
        </member>
        <member name="M:Love.FileSystem.Read(System.Byte[],System.Int64)">
            <summary>
            Read the contents of a file.
            </summary>
            <param name="filename">The name (and path) of the file. (UTF-8 byte array needed)</param>
            <param name="len">How many bytes to read. (-1 means all)</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.Write(System.Byte[],System.Byte[])">
            <summary>
            Write data to a file in the save directory. If the file existed already, it will be completely replaced by the new contents.
            </summary>
            <param name="filename">The name (and path) of the file.(UTF-8 byte need)</param>
            <param name="input">The data to write to the file.</param>
        </member>
        <member name="M:Love.FileSystem.Append(System.Byte[],System.Byte[])">
            <summary>
            Append data to an existing file. (UTF-8 byte array version)
            </summary>
            <param name="filename">The name (and path) of the file.</param>
            <param name="input">The data to append to the file.</param>
        </member>
        <member name="M:Love.FileSystem.GetDirectoryItems(System.Byte[])">
            <summary>
            <para>Returns a table with the names of files and subdirectories in the specified path. The table is not sorted in any way; the order is undefined.</para>
            <para>If the path passed to the function exists in the game and the save directory, it will list the files and directories from both places.</para>
            </summary>
            <param name="dir">The directory.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem._GetLastModified(System.Byte[])">
            <summary>
            <para>Deprecated in LÖVE 11.0</para>
            <para>Gets the last modification time of a file.</para>
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.AreSymlinksEnabled">
            <summary>
            Gets whether love.filesystem follows symbolic links.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem._GetSourceBaseDirectory">
            <summary>
            <para>no need for C# version</para>
            Returns the full path to the directory containing the .love file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem._GetRequirePath">
            <summary>
            <para>no need for C# version</para>
            Gets the filesystem paths that will be searched when require is called.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem._SetRequirePath(System.Byte[])">
            <summary>
            <para>no need for C# version</para>
            <para>Sets the filesystem paths that will be searched when require is called.</para>
            <para>The paths string given to this function is a sequence of path templates separated by semicolons. The argument passed to require will be inserted in place of any question mark ("?") character in each template (after the dot characters in the argument passed to require are replaced by directory separators.)</para>
            <para>The paths are relative to the game's source and save directories, as well as any paths mounted with love.filesystem.mount.</para>
            </summary>
            <param name="paths"></param>
        </member>
        <member name="M:Love.FileSystem.NewFile(System.String,Love.FileMode)">
            <summary>
            Creates a new File object. It needs to be opened before it can be accessed.
            </summary>
            <param name="filename">The filename of the file.</param>
            <param name="fmode_type">The mode to open the file in.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.NewFileData(System.String,System.String)">
            <summary>
            Creates a new FileData object.
            </summary>
            <param name="contents">The contents of the file.</param>
            <param name="filename">The name of the file.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.NewFileData(System.Byte[],System.String)">
            <summary>
            Creates a new FileData object.
            </summary>
            <param name="contents">The contents of the file.</param>
            <param name="filename">The name of the file.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.Init(System.String)">
            <summary>
            Initializes FileSystem, will be called internally, so should not be used explictly.
            </summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.GetInfo(System.String)">
            <summary>
            Gets information about the specified file or directory.
            </summary>
            <param name="path">The file or directory path to check.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.SetIdentity(System.String,System.Boolean)">
            <summary>
            Sets the write directory for your game. Note that you can only set the name of the folder to store your files in, not the location.
            </summary>
            <param name="path">The new identity that will be used as write directory.</param>
            <param name="append">Whether the identity directory will be searched when reading a filepath before or after the game's source directory and any currently.
            TRUE: results in searching source before searching save directory; FALSE: results in searching game save directory before searching source directorymounted archives.</param>
        </member>
        <member name="M:Love.FileSystem.SetSource(System.String)">
            <summary>
            Sets the source of the game, where the code is present. This function can only be called once, and is normally automatically done by LÖVE.
            </summary>
            <param name="path">Absolute path to the game's source folder.</param>
        </member>
        <member name="M:Love.FileSystem.Mount(System.String,System.String,System.Boolean)">
            <summary>
            Mounts a zip file or folder in the game's save directory for reading. It is also possible to mount love.filesystem.getSourceBaseDirectory if the game is in fused mode.
            </summary>
            <param name="archive">The folder or zip file in the game's save directory to mount.</param>
            <param name="mountpoint">The new path the archive will be mounted to.</param>
            <param name="appendToPath">Whether the archive will be searched when reading a filepath before or after already-mounted archives. This includes the game's source and save directories.</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.GetRealDirectory(System.String)">
            <summary>
            <para>Gets the platform-specific absolute path of the directory containing a filepath.</para>
            </summary>
            <param name="filename">The filepath to get the directory of.</param>
            <returns>The platform-specific full path of the directory containing the filepath.</returns>
        </member>
        <member name="M:Love.FileSystem.CreateDirectory(System.String)">
            <summary>
            <para>Recursively creates a directory.</para>
            <para>When called with "a/b" it creates both "a" and "a/b", if they don't exist already.</para>
            </summary>
            <param name="name">The directory to create.</param>
            <returns>True if the directory was created, false if not.</returns>
        </member>
        <member name="M:Love.FileSystem.Remove(System.String)">
            <summary>
            Removes a file (or directory).
            </summary>
            <param name="path">The file or directory to remove.</param>
        </member>
        <member name="M:Love.FileSystem.Read(System.String,System.Int64)">
            <summary>
            Read the contents of a file.
            </summary>
            <param name="filename">The name (and path) of the file.</param>
            <param name="len">How many bytes to read. (-1 means all)</param>
            <returns></returns>
        </member>
        <member name="M:Love.FileSystem.Write(System.String,System.Byte[])">
            <summary>
            Write data to a file in the save directory. If the file existed already, it will be completely replaced by the new contents.
            </summary>
            <param name="filename">The name (and path) of the file.</param>
            <param name="input">The data to write to the file.</param>
        </member>
        <member name="M:Love.FileSystem.Write(System.String,System.String)">
            <summary>
            Write data to a file in the save directory. If the file existed already, it will be completely replaced by the new contents.
            <para>encode with UTF-8</para>
            </summary>
            <param name="filename">The name (and path) of the file.</param>
            <param name="input">The string data to write to the file.</param>
        </member>
        <member name="M:Love.FileSystem.Append(System.String,System.Byte[])">
            <summary>
            Append data to an existing file.
            </summary>
            <param name="filename">The name (and path) of the file.</param>
            <param name="input">The data to append to the file.</param>
        </member>
        <member name="M:Love.FileSystem.Append(System.String,System.String)">
            <summary>
            Append text to an existing file (encode with UTF-8).
            </summary>
            <param name="filename">The name (and path) of the file.</param>
            <param name="txt">string to append</param>
        </member>
        <member name="M:Love.FileSystem.GetDirectoryItems(System.String)">
            <summary>
            <para>Returns a table with the names of files and subdirectories in the specified path. The array is not sorted in any way; the order is undefined.</para>
            <para>If the path passed to the function exists in the game and the save directory, it will list the files and directories from both places.</para>
            </summary>
            <param name="dir">The directory.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Sound.NewDecoder(System.String,System.Int32)">
            <summary>
            Attempts to find a decoder for the encoded sound data in the specified file.
            </summary>
            <param name="filename">The filename of the file with encoded sound data.</param>
            <param name="bufferSize">The size of each decoded chunk, in bytes.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Sound.NewSoundData(Love.File)">
            <summary>
            <para> Creates a new SoundData.</para>
            <para>It's also possible to create SoundData with a custom sample rate, channel and bit depth.</para>
            <para>The sound data will be decoded to the memory in a raw format. It is recommended to create only short sounds like effects, as a 3 minute song uses 30 MB of memory this way.</para>
            </summary>
            <param name="file">A File pointing to an audio file.</param>
            <returns>A new SoundData object.</returns>
        </member>
        <member name="M:Love.Sound.NewSoundData(System.String)">
            <summary>
            <para> Creates a new SoundData.</para>
            <para>It's also possible to create SoundData with a custom sample rate, channel and bit depth.</para>
            <para>The sound data will be decoded to the memory in a raw format. It is recommended to create only short sounds like effects, as a 3 minute song uses 30 MB of memory this way.</para>
            </summary>
            <param name="filename">The file name of the file to load.</param>
            <returns>A new SoundData object.</returns>
        </member>
        <member name="M:Love.Sound.NewDecoder(Love.FileData,System.Int32)">
            <summary>
            Attempts to find a decoder for the encoded sound data in the specified file.
            </summary>
            <param name="fdata">The file data with encoded sound data.</param>
            <param name="buffersize">The size of each decoded chunk, in bytes.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Sound.NewDecoder(Love.File,System.Int32)">
            <summary>
            Attempts to find a decoder for the encoded sound data in the specified file.
            </summary>
            <param name="file">The file with encoded sound data.</param>
            <param name="buffersize">The size of each decoded chunk, in bytes.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Sound.NewSoundData(Love.Decoder)">
            <summary>
            <para>Creates a new SoundData.</para>
            <para>It's also possible to create SoundData with a custom sample rate, channel and bit depth.</para>
            <para>The sound data will be decoded to the memory in a raw format. It is recommended to create only short sounds like effects, as a 3 minute song uses 30 MB of memory this way.</para>
            </summary>
            <param name="decoder">Decode data from this Decoder until EOF.</param>
            <returns>A new SoundData object.</returns>
        </member>
        <member name="M:Love.Sound.NewSoundData(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>Creates a new SoundData.</para>
            <para>It's also possible to create SoundData with a custom sample rate, channel and bit depth.</para>
            <para>The sound data will be decoded to the memory in a raw format. It is recommended to create only short sounds like effects, as a 3 minute song uses 30 MB of memory this way.</para>
            </summary>
            <param name="samples">Total number of samples.</param>
            <param name="sampleRate">Number of samples per second</param>
            <param name="bits">Bits per sample (8 or 16).</param>
            <param name="channels">Either 1 for mono or 2 for stereo.</param>
            <returns>A new SoundData object.</returns>
        </member>
        <member name="M:Love.Audio.NewSource(Love.FileData,Love.SourceType)">
            <summary>
            Creates a new Source from file data. 
            </summary>
            <param name="fdata">The FileData to create a Source from.</param>
            <param name="type">Streaming or static source.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Audio.NewSource(System.String,Love.SourceType)">
            <summary>
            Creates a new Source from file name. 
            </summary>
            <param name="filename">The filepath to the audio file.</param>
            <param name="type">Streaming or static source.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Audio.GetOrientation">
            <summary>
            Returns the orientation of the listener.
            </summary>
            <returns>tuple (Forward vector of the listener orientation, Up vector of the listener orientation.)</returns>
        </member>
        <member name="M:Love.Audio.NewSource(Love.Decoder,Love.SourceType)">
            <summary>
            Creates a new Source from a Decoder. 
            </summary>
            <param name="decoder">The Decoder to create a Source from.</param>
            <param name="type">Streaming or static source.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Audio.NewSource(Love.SoundData)">
            <summary>
            Sources created from SoundData are always static.
            </summary>
            <param name="sd">The SoundData to create a Source from.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Audio.GetActiveSourceCount">
            <summary>
            Gets the current number of simultaneously playing sources.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Audio.Stop">
            <summary>
            Stops all currently played sources.
            </summary>
        </member>
        <member name="M:Love.Audio.Stop(Love.Source[])">
            <summary>
            Stops specified source.
            </summary>
        </member>
        <member name="M:Love.Audio.Pause">
            <summary>
            Pauses all currently played Sources.
            </summary>
        </member>
        <member name="M:Love.Audio.Pause(Love.Source[])">
            <summary>
            Pauses specific played Sources.
            </summary>
        </member>
        <member name="M:Love.Audio.Play(Love.Source[])">
            <summary>
            Plays the specified Source.
            </summary>
            <param name="sources"></param>
        </member>
        <member name="M:Love.Audio.SetVolume(System.Single)">
            <summary>
            Sets the master volume.
            </summary>
            <param name="v">1.0 is max and 0.0 is off.</param>
        </member>
        <member name="M:Love.Audio.GetVolume">
            <summary>
            Returns the master volume.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Audio.SetPosition(System.Single,System.Single,System.Single)">
            <summary>
            Sets the position of the listener.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:Love.Audio.GetPosition">
            <summary>
            Returns the position of the listener.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Audio.SetOrientation(Love.Vector3,Love.Vector3)">
            <summary>
            Sets the orientation of the listener.
            </summary>
            <param name="forward">Forward vector of the listener orientation.</param>
            <param name="up">Up vector of the listener orientation.</param>
        </member>
        <member name="M:Love.Audio.GetOrientation(Love.Vector3@,Love.Vector3@)">
            <summary>
            Returns the orientation of the listener.
            </summary>
            <param name="forward">Forward vector of the listener orientation.</param>
            <param name="up">Up vector of the listener orientation.</param>
        </member>
        <member name="M:Love.Audio.SetVelocity(System.Single,System.Single,System.Single)">
            <summary>
            Sets the velocity of the listener.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:Love.Audio.GetVelocity">
            <summary>
            Returns the velocity of the listener.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Audio.SetDopplerScale(System.Single)">
            <summary>
            Sets a global scale factor for doppler effects.
            </summary>
            <param name="scale">The new doppler scale factor. The scale must be greater than 0.</param>
        </member>
        <member name="M:Love.Audio.GetDopplerScale">
            <summary>
            Gets the global scale factor for doppler effects.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Audio.SetDistanceModel(Love.DistanceModel)">
            <summary>
            Sets the distance attenuation model.
            </summary>
            <param name="distancemodel_type"></param>
        </member>
        <member name="M:Love.Audio.GetDistanceModel">
            <summary>
            Returns the distance attenuation model.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Love.Image">
            <summary>
            Provides an interface to decode encoded image data.
            </summary>
        </member>
        <member name="M:Love.Image.NewImageData(System.String)">
            <summary>
            Creates a new <see cref="T:Love.ImageData"/> object.
            </summary>
            <param name="filename">The filename of the image file.</param>
            <returns>The new ImageData object.</returns>
        </member>
        <member name="M:Love.Image.NewCompressedData(System.String)">
            <summary>
            Create a new <see cref="T:Love.CompressedImageData"/> object from a compressed image file. LÖVE supports several compressed texture formats, enumerated in the <see cref="T:Love.PixelFormat"/> page.
            </summary>
            <param name="filename">The filename of the compressed image file.</param>
            <returns>The new CompressedImageData object.</returns>
        </member>
        <member name="M:Love.Image.NewImageData(Love.Vector4[0:,0:],Love.ImageDataPixelFormat)">
            <summary>
            Creates a new ImageData object.
            <para> Vector4[x, y] - new Vector4(0.1f, 0.2f, 0.3f, 0.4f) </para>
            </summary>
            <param name="rawData">color data to set</param>
            <param name="format">The pixel format of the ImageData.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Image.NewImageData(Love.Vector4[][],Love.ImageDataPixelFormat)">
            <summary>
            Creates a new ImageData object.
            </summary>
            <param name="rawData">Optional raw byte data to load into the ImageData, in the format specified by format.</param>
            <param name="format">The pixel format of the ImageData.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Image.IsCompressed(System.String)">
            <summary>
            Determines whether a file can be loaded as <see cref="T:Love.CompressedImageData"/>.
            </summary>
            <param name="filename">The filename of the potentially compressed image file.</param>
            <returns>Whether the file can be loaded as <see cref="T:Love.CompressedImageData"/> or not.</returns>
        </member>
        <member name="M:Love.Image.NewImageData(System.UInt32,System.UInt32,Love.ImageDataPixelFormat,System.Byte[])">
            <summary>
            Creates a new <see cref="T:Love.ImageData"/> object.
            </summary>
            <param name="w">The width of the ImageData.</param>
            <param name="h">The height of the ImageData.</param>
            <param name="format">The pixel format of the ImageData.</param>
            <param name="data">Optional raw byte data to load into the ImageData, in the format specified by format.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Image.NewImageData(System.Int32,System.Int32,Love.ImageDataPixelFormat,System.Byte[])">
            <summary>
            Creates a new <see cref="T:Love.ImageData"/> object.
            </summary>
            <param name="w">The width of the ImageData.</param>
            <param name="h">The height of the ImageData.</param>
            <param name="format">The pixel format of the ImageData.</param>
            <param name="data">Optional raw byte data to load into the ImageData, in the format specified by format.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Image.NewImageData(Love.FileData)">
            <summary>
            Creates a new <see cref="T:Love.ImageData"/> object.
            </summary>
            <param name="data">The encoded file data to decode into image data.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Image.NewCompressedData(Love.FileData)">
            <summary>
            Create a new <see cref="T:Love.CompressedImageData"/> object from a compressed image file. LÖVE supports several compressed texture formats, enumerated in the <see cref="T:Love.PixelFormat"/> page.
            </summary>
            <param name="data">A FileData containing a compressed image.</param>
            <returns>The new CompressedImageData object.</returns>
        </member>
        <member name="M:Love.Image.IsCompressed(Love.FileData)">
            <summary>
            Determines whether a file can be loaded as <see cref="T:Love.CompressedImageData"/>.
            </summary>
            <param name="data">A FileData potentially containing a compressed image.</param>
            <returns>Whether the file can be loaded as <see cref="T:Love.CompressedImageData"/> or not.</returns>
        </member>
        <member name="M:Love.Image.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Image.IsCompressed">
            <summary>
            Gets whether the Image was created from <see cref="T:Love.CompressedImageData"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Image.ReplacePixels(Love.ImageData,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Replace the contents of an Image.
            </summary>
            <param name="imageData">The new ImageData to replace the contents with.</param>
            <param name="slice">Which cubemap face, array index, or volume layer to replace, if applicable.</param>
            <param name="mipmap">The mimap level to replace, if the Image has mipmaps.</param>
            <param name="x">The x-offset in pixels from the top-left of the image to replace. The given ImageData's width plus this value must not be greater than the pixel width of the Image's specified mipmap level.</param>
            <param name="y">The y-offset in pixels from the top-left of the image to replace. The given ImageData's height plus this value must not be greater than the pixel height of the Image's specified mipmap level.</param>
            <param name="reloadmipmaps">Whether to generate new mipmaps after replacing the Image's pixels. True by default if the Image was created with automatically generated mipmaps, false by default otherwise.</param>
        </member>
        <member name="M:Love.ImageData.MapPixel(Love.ImageData.MapPixelColorDelegate)">
            <summary>
            <para> Transform an image by applying a function to every pixel. </para>
            <para> This function is a higher-order function(https://en.wikipedia.org/wiki/Higher-order_function). It takes another function as a parameter, and calls it once for each pixel in the ImageData. </para>
            <para>The passed function is called with six parameters for each pixel in turn. The parameters are numbers that represent the x and y coordinates of the pixel and its red, green, blue and alpha values. The function should return the new red, green, blue, and alpha values for that pixel.</para>
            </summary>
            <param name="func">Function to apply to every pixel.</param>
        </member>
        <member name="M:Love.ImageData.MapPixel(Love.ImageData.MapPixelColorDelegate,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para> Transform an image by applying a function to every pixel. </para>
            <para> This function is a higher-order function(https://en.wikipedia.org/wiki/Higher-order_function). It takes another function as a parameter, and calls it once for each pixel in the ImageData. </para>
            <para>The passed function is called with six parameters for each pixel in turn. The parameters are numbers that represent the x and y coordinates of the pixel and its red, green, blue and alpha values. The function should return the new red, green, blue, and alpha values for that pixel.</para>
            </summary>
            <param name="func">Function to apply to every pixel.</param>
            <param name="sx">The x-axis of the top-left corner of the area within the ImageData to apply the function to.</param>
            <param name="sy">The y-axis of the top-left corner of the area within the ImageData to apply the function to.</param>
            <param name="w">The width of the area within the ImageData to apply the function to.</param>
            <param name="h">The height of the area within the ImageData to apply the function to.</param>
        </member>
        <member name="M:Love.ImageData.MapPixel(Love.ImageData.MapPixelDelegate,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para> Advance version of <see cref="M:Love.ImageData.MapPixel(Love.ImageData.MapPixelColorDelegate,System.Int32,System.Int32,System.Int32,System.Int32)"/>,</para>
            <para>if you don't know how to handle pixel format, please use <see cref="M:Love.ImageData.MapPixel(Love.ImageData.MapPixelColorDelegate,System.Int32,System.Int32,System.Int32,System.Int32)"/> </para>
            <para>if you need speed, consider use <see cref="M:Love.ImageData.SetPixels(Love.Pixel[])"/></para>
            </summary>
            <param name="func">Function to apply to every pixel.</param>
            <param name="sx">The x-axis of the top-left corner of the area within the ImageData to apply the function to.</param>
            <param name="sy">The y-axis of the top-left corner of the area within the ImageData to apply the function to.</param>
            <param name="w">The width of the area within the ImageData to apply the function to.</param>
            <param name="h">The height of the area within the ImageData to apply the function to.</param>
        </member>
        <member name="M:Love.ImageData.MapPixel(Love.ImageData.MapPixelDelegate)">
            <summary>
            <para> Advance version of <see cref="M:Love.ImageData.MapPixel(Love.ImageData.MapPixelColorDelegate,System.Int32,System.Int32,System.Int32,System.Int32)"/>,</para>
            <para>if you don't know how to handle pixel format, please use <see cref="M:Love.ImageData.MapPixel(Love.ImageData.MapPixelColorDelegate,System.Int32,System.Int32,System.Int32,System.Int32)"/> </para>
            <para>if you need speed, consider use <see cref="M:Love.ImageData.SetPixels(Love.Pixel[])"/></para>
            </summary>
            <param name="func">Function to apply to every pixel.</param>
        </member>
        <member name="M:Love.ImageData.GetPixels">
            <summary>
            get every pixel
            </summary>
        </member>
        <member name="M:Love.ImageData.GetPixelsFloat">
            <summary>
            get every pixel, as Float4 format
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.ImageData.SetPixels(Love.Pixel[])">
            <summary>
            set every pixel with given data
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Love.ImageData.SetPixelsFloat(Love.Vector4[])">
            <summary>
            set every pixel with given data, function will convert Float4 to correct pixel format automatically
            </summary>
            <param name="data">color data to set</param>
        </member>
        <member name="M:Love.ImageData.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.ImageData.GetWidth">
            <summary>
            Gets the width of the ImageData in pixels.	
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.ImageData.GetHeight">
            <summary>
            Gets the height of the ImageData in pixels.	
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.ImageData.GetPixel(System.Int32,System.Int32)">
            <summary>
            <para>Gets the color of a pixel at a specific position in the image.</para>
            </summary>
            <param name="x">The position of the pixel on the x-axis.</param>
            <param name="y">The position of the pixel on the y-axis.</param>
            <returns></returns>
        </member>
        <member name="M:Love.ImageData.SetPixel(System.Int32,System.Int32,Love.Pixel)">
            <summary>
            <para>Sets the color of a pixel at a specific position in the image. </para>
            </summary>
            <param name="x">The position of the pixel on the x-axis.</param>
            <param name="y">The position of the pixel on the y-axis.</param>
            <param name="pixel"></param>
        </member>
        <member name="M:Love.ImageData.GetFormat">
            <summary>
            Gets the pixel format of the ImageData.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.ImageData.Paste(Love.ImageData,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Paste into ImageData from another source ImageData.
            </summary>
            <param name="src_imageData">Source ImageData from which to copy.</param>
            <param name="dx">Destination top-left position on x-axis.</param>
            <param name="dy">Destination top-left position on y-axis.</param>
            <param name="sx">Source top-left position on x-axis.</param>
            <param name="sy">Source top-left position on y-axis.</param>
            <param name="sw">Source width.</param>
            <param name="sh">Source height.</param>
        </member>
        <member name="M:Love.ImageData.Encode(Love.ImageFormat,System.Boolean,System.Byte[])">
            <summary>
            Encodes the ImageData and optionally writes it to the save directory.
            </summary>
            <param name="format_type">The format to encode the image as.</param>
            <param name="writeToFile">Whether to write to the specified file</param>
            <param name="filename">The filename to write the file to. If null, no file will be written but the FileData will still be returned.</param>
            <returns></returns>
        </member>
        <member name="M:Love.ImageData.Encode(Love.ImageFormat,System.String)">
            <summary>
            Encodes the ImageData and optionally writes it to the save directory.
            </summary>
            <param name="format_type">The format to encode the image as.</param>
            <param name="filename">The filename to write the file to. If null, no file will be written but the FileData will still be returned.</param>
            <returns></returns>
        </member>
        <member name="T:Love.Mouse">
            <summary>
            Provides an interface to the user's mouse.
            </summary>
        </member>
        <member name="M:Love.Mouse.NewCursor(System.String,System.Int32,System.Int32)">
            <summary>
            <para>Creates a new hardware Cursor object from an image file or ImageData.</para>
            <para>Hardware cursors are framerate-independent and work the same way as normal operating system cursors. Unlike drawing an image at the mouse's current coordinates, hardware cursors never have visible lag between when the mouse is moved and when the cursor position updates, even at low framerates.</para>
            <para>The hot spot is the point the operating system uses to determine what was clicked and at what position the mouse cursor is. For example, the normal arrow pointer normally has its hot spot at the top left of the image, but a crosshair cursor might have it in the middle.</para>
            </summary>
            <param name="filename">Path to the image to use for the new Cursor.</param>
            <param name="hotX">The x-coordinate in the image of the cursor's hot spot.</param>
            <param name="hotY">The y-coordinate in the image of the cursor's hot spot.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.GetPosition">
            <summary>
            Returns the current position of the mouse.
            </summary>
            <returns>The position of the mouse.</returns>
        </member>
        <member name="M:Love.Mouse.NewCursor(Love.ImageData,System.Int32,System.Int32)">
            <summary>
            <para>Creates a new hardware Cursor object from an image file or ImageData.</para>
            <para>Hardware cursors are framerate-independent and work the same way as normal operating system cursors. Unlike drawing an image at the mouse's current coordinates, hardware cursors never have visible lag between when the mouse is moved and when the cursor position updates, even at low framerates.</para>
            <para>The hot spot is the point the operating system uses to determine what was clicked and at what position the mouse cursor is. For example, the normal arrow pointer normally has its hot spot at the top left of the image, but a crosshair cursor might have it in the middle.</para>
            </summary>
            <param name="imageData">The ImageData to use for the new Cursor.</param>
            <param name="hotX">The x-coordinate in the image of the cursor's hot spot.</param>
            <param name="hotY">The y-coordinate in the image of the cursor's hot spot.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.GetSystemCursor(Love.SystemCursor)">
            <summary>
            <para> Gets a Cursor object representing a system-native hardware cursor. </para>
            <para>Hardware cursors are framerate-independent and work the same way as normal operating system cursors. Unlike drawing an image at the mouse's current coordinates, hardware cursors never have visible lag between when the mouse is moved and when the cursor position updates, even at low framerates.</para>
            </summary>
            <param name="sysctype"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.SetCursor(Love.Cursor)">
            <summary>
            Sets the current mouse cursor.
            </summary>
            <param name="cursor"></param>
        </member>
        <member name="M:Love.Mouse.GetCursor">
            <summary>
            Gets the current Cursor.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.IsCursorSupported">
            <summary>
            Gets whether cursor functionality is supported.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.GetXDouble">
            <summary>
            Returns the current x-position of the mouse.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.GetYDouble">
            <summary>
            Returns the current y-position of the mouse.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.GetX">
            <summary>
            Returns the current x-position of the mouse.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.GetY">
            <summary>
            Returns the current y-position of the mouse.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.GetPosition(System.Double@,System.Double@)">
            <summary>
            Returns the current x/y-position of the mouse.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.SetX(System.Double)">
            <summary>
            Sets the current X position of the mouse.
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Love.Mouse.SetY(System.Double)">
            <summary>
            Sets the current Y position of the mouse.
            </summary>
            <param name="y"></param>
        </member>
        <member name="M:Love.Mouse.SetPosition(System.Double,System.Double)">
            <summary>
            Sets the current X/Y position of the mouse.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Love.Mouse.IsDown(System.Int32)">
            <summary>
            Checks whether a certain button is down.
            <para>This function does not detect mouse wheel scrolling; you must use the love.wheelmoved (or love.mousepressed in version 0.9.2 and older) callback for that.</para>
            </summary>
            <param name="buttonIndex">The index of a button to check. 1 is the primary mouse button, 2 is the secondary mouse button and 3 is the middle button. Further buttons are mouse dependant.</param>
            <returns>True if any specified button is down.</returns>
        </member>
        <member name="M:Love.Mouse.SetVisible(System.Boolean)">
            <summary>
            Sets the current visibility of the cursor.
            </summary>
            <param name="visible"></param>
        </member>
        <member name="M:Love.Mouse.IsVisible">
            <summary>
            Checks if the cursor is visible.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.SetGrabbed(System.Boolean)">
            <summary>
            Grabs the mouse and confines it to the window.
            </summary>
            <param name="grabbed"></param>
        </member>
        <member name="M:Love.Mouse.IsGrabbed">
            <summary>
            Checks if the mouse is grabbed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.SetRelativeMode(System.Boolean)">
            <summary>
            <para>WARNNING: THIS API NOT STABLE, IT WILL CRASHED! </para>
            <para>Sets whether relative mode is enabled for the mouse. </para>
            <para>When relative mode is enabled, the cursor is hidden and doesn't move when the mouse does, but relative mouse motion events are still generated via love.mousemoved. This lets the mouse move in any direction indefinitely without the cursor getting stuck at the edges of the screen.</para>
            <para>The reported position of the mouse may not be updated while relative mode is enabled, even when relative mouse motion events are generated.</para>
            </summary>
            <param name="enable">True to enable relative mode, false to disable it.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Mouse.GetRelativeMode">
            <summary>
            Gets whether relative mode is enabled for the mouse.
            </summary>
            <returns>True if relative mode is enabled, false if it's disabled.</returns>
        </member>
        <member name="M:Love.Video.NewVideoStream(System.String)">
            <summary>
            Creates a new VideoStream. Currently only Ogg Theora video files are supported. VideoStreams can't draw videos, see love.graphics.newVideo for that.
            </summary>
            <param name="filename">The file path to the Ogg Theora video file.</param>
            <returns>A new VideoStream.</returns>
        </member>
        <member name="M:Love.Video.Play">
            <summary>
            Starts playing the Video.
            </summary>
        </member>
        <member name="M:Love.Video.Pause">
            <summary>
            Pauses the Video.
            </summary>
        </member>
        <member name="M:Love.Video.Seek(System.Double)">
            <summary>
            Sets the current playback position of the Video.
            </summary>
            <param name="offset"></param>
        </member>
        <member name="M:Love.Video.Rewind">
            <summary>
            Rewinds the Video to the beginning.
            </summary>
        </member>
        <member name="M:Love.Video.Tell">
            <summary>
            Gets the current playback position of the Video.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Video.IsPlaying">
            <summary>
            Gets whether the Video is currently playing.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Video.NewVideoStream(Love.File)">
            <summary>
            Creates a new VideoStream. Currently only Ogg Theora video files are supported. VideoStreams can't draw videos, see love.graphics.newVideo for that.
            </summary>
            <param name="file">The File object containing the Ogg Theora video.</param>
            <returns>A new VideoStream.</returns>
        </member>
        <member name="M:Love.Video.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Graphics.NewCanvas">
            <summary>
            Creates a new Canvas.
            <para>This function can be slow if it is called repeatedly, such as from love.update or love.draw. If you need to use a specific resource often, create it once and store it somewhere it can be reused!</para>
            </summary>
            <returns>A new Canvas with dimensions equal to the window's size in pixels.</returns>
        </member>
        <member name="M:Love.Graphics.NewText(Love.Font,System.String)">
            <summary>
            Creates a new drawable Text object.
            </summary>
            <param name="font">The font to use for the text.</param>
            <param name="coloredStr">The initial string of text that the new Text object will contain. May be nil.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.NewImage(System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Image from a filepath.
            </summary>
            <param name="filename">The filepath to the image file .</param>
            <param name="flagMipmaps">If true, mipmaps for the image will be automatically generated (or taken from the images's file if possible, if the image originated from a CompressedImageData). If this value is a table, it should contain a list of other filenames of images of the same format that have progressively half-sized dimensions, all the way down to 1x1. Those images will be used as this Image's mipmap levels.</param>
            <param name="flagLinear">True if the image's pixels should be interpreted as being linear RGB rather than sRGB-encoded, if gamma-correct rendering is enabled. Has no effect otherwise.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.NewFont(System.Int32,Love.HintingMode)">
            <summary>
            Create a new instance of the default font (Vera Sans) with a custom size.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.NewBMFont(System.String,System.String[])">
            <summary>
            </summary>
            <param name="filename">The filepath to the BMFont file.</param>
            <param name="imageFileName">The filepath to the BMFont's image file.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.NewBMFont(System.String)">
            <summary>
            Create a new BMFont. The filepath to the BMFont's image file specified inside the BMFont file will be used.
            </summary>
            <param name="filename">The filepath to the BMFont file.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.NewImageFont(System.String,System.String,System.Int32)">
            <summary>
            Creates a new Font by loading a specifically formatted image.
            <para>In versions prior to 0.9.0, LÖVE expects ISO 8859-1 encoding for the glyphs string.</para>
            <para>	This function can be slow if it is called repeatedly, such as from Scene.Update. If you need to use a specific resource often, create it once and store it somewhere it can be reused!</para>
            </summary>
            <param name="filename">The filepath to the image file.</param>
            <param name="glyphs">A string of the characters in the image in order from left to right.</param>
            <param name="extraspacing">Additional spacing (positive or negative) to apply to each glyph in the Font.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.NewFont(System.String,System.Int32,Love.HintingMode)">
            <summary>
            Create a new TrueType font.
            </summary>
            <param name="filename">The filepath to the TrueType font file.</param>
            <param name="size">The size of the font in pixels.</param>
            <param name="hinting">True Type hinting mode.</param>
            <returns>A Font object which can be used to draw text on screen.</returns>
        </member>
        <member name="M:Love.Graphics.NewVideo(System.String,System.Boolean,System.Nullable{System.Single})">
            <summary>
            Creates a new drawable Video. Currently only Ogg Theora video files are supported.
            </summary>
            <param name="filename">The file path to the Ogg Theora video file.</param>
            <param name="audio">Whether to try to load the video's audio into an audio Source. If not explicitly set to true or false, it will try without causing an error if the video has no audio.</param>
            <param name="dipScale">The DPI scale factor of the video. if it was null, value will be Graphics.GetDPIScale()</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.Clear">
            <summary>
            Clears the screen to transparent black (0, 0, 0, 0).
            </summary>
        </member>
        <member name="M:Love.Graphics.SetColor(Love.Color)">
            <summary>
            Sets the color used for drawing.
            </summary>
        </member>
        <member name="M:Love.Graphics.SetColor(Love.Vector4)">
            <summary>
            Sets the color used for drawing.
            </summary>
        </member>
        <member name="M:Love.Graphics.Rectangle(Love.DrawMode,Love.RectangleF)">
            <summary>
            Draws a rectangle.
            </summary>
            <param name="mode">How to draw the rectangle.</param>
            <param name="rect">the rectangle to draw.</param>
        </member>
        <member name="M:Love.Graphics.Rectangle(Love.DrawMode,Love.Rectangle)">
            <summary>
            Draws a rectangle.
            </summary>
            <param name="mode">How to draw the rectangle.</param>
            <param name="rect">the rectangle to draw.</param>
        </member>
        <member name="M:Love.Graphics.Arc(Love.DrawMode,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Draws an arc using the "pie" ArcType.
            </summary>
            <param name="draw_mode"></param>
            <param name="x">The position of the center along x-axis.</param>
            <param name="y">The position of the center along y-axis.</param>
            <param name="radius">Radius of the arc.</param>
            <param name="angle1">The angle at which the arc begins.</param>
            <param name="angle2">The angle at which the arc terminates.</param>
        </member>
        <member name="M:Love.Graphics.Discard(System.Boolean,System.Boolean)">
            <summary>
            Discards (trashes) the contents of the screen or active Canvas. This is a performance optimization function with niche use cases.
            </summary>
            <param name="discardColor">Whether to discard the texture(s) of the active Canvas(es) (the contents of the screen if no Canvas is active.)</param>
            <param name="discardStencil">Whether to discard the contents of the stencil buffer of the screen / active Canvas.</param>
        </member>
        <member name="M:Love.Graphics.NewMesh(Love.Vertex[],Love.MeshDrawMode,Love.SpriteBatchUsage)">
            <summary>
            Creates a new Mesh.
            <para>Use Mesh.SetTexture if the Mesh should be textured with an Image or Canvas when it's drawn.</para>
            <para>In versions prior to 11.0, color and byte component values were within the range of 0 to 255 instead of 0 to 1.</para>
            </summary>
            <param name="vertices">The array filled with vertex information tables for each vertex as follows:</param>
            <param name="drawMode">How the vertices are used when drawing. The default mode "fan" is sufficient for simple convex polygons.</param>
            <param name="usage">The expected usage of the Mesh. The specified usage mode affects the Mesh's memory usage and performance.</param>
            <returns>The new mesh.</returns>
        </member>
        <member name="M:Love.Graphics.Printf(System.String,System.Single,System.Single,System.Single,Love.AlignMode,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            <para> Draws formatted text, with word wrap and alignment.</para>
            <para> See additional notes in love.graphics.print. </para>
            <para>In version 0.9.2 and earlier, wrapping was implemented by breaking up words by spaces and putting them back together to make sure things fit nicely within the limit provided. However, due to the way this is done, extra spaces between words would end up missing when printed on the screen, and some lines could overflow past the provided wrap limit. In version 0.10.0 and newer this is no longer the case.</para>
            <para>Aligning does not work as one might expect! It doesn't align to the x/y coordinates given, but in a rectangle, where the limit is the width.</para>
            <para>Text may appear blurry if it's rendered at non-integer pixel locations.</para>
            </summary>
            <param name="text">A text string.</param>
            <param name="x">The position on the x-axis.</param>
            <param name="y">The position on the y-axis.</param>
            <param name="wrap"></param>
            <param name="align_type">Wrap the line after this many horizontal pixels.</param>
            <param name="angle">Orientation (radians).</param>
            <param name="sx">Scale factor (x-axis).</param>
            <param name="sy">Scale factor (y-axis).</param>
            <param name="ox">Origin offset (x-axis).</param>
            <param name="oy">Origin offset (y-axis).</param>
            <param name="kx">Shearing factor (x-axis).</param>
            <param name="ky">Shearing factor (y-axis).</param>
        </member>
        <member name="M:Love.Graphics.SetStencilTest">
            <summary>
            Disables stencil testing.
            </summary>
        </member>
        <member name="M:Love.Graphics.GetDimensions">
            <summary>
            Gets the width and height of the window.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.Line(System.Single[])">
            <summary>
            Draws lines between points.
            </summary>
            <param name="points">must be an integer multiple of 2. [first(x, y), second(x, y) ....]</param>
        </member>
        <member name="M:Love.Graphics.Points(System.Single[])">
            <summary>
            Draws one or more points.
            </summary>
            <param name="points">must be an integer multiple of 2. [first(x, y), second(x, y) ....]</param>
        </member>
        <member name="M:Love.Graphics.Polygon(Love.DrawMode,System.Single[])">
            <summary>
            Draw a polygon.
            </summary>
            <param name="mode">How to draw the polygon.</param>
            <param name="points">must be an integer multiple of 2. [first(x, y), second(x, y) ....]</param>
        </member>
        <member name="M:Love.Graphics.Scale(Love.Vector2)">
            <summary>
            <para>以二维方式缩放坐标系。</para>
            <para>默认情况下，LÖVE中的坐标系在水平和垂直方向上一对一显示像素，x轴向右增加，y轴向下增加。 缩放坐标系会改变这种关系。</para>
            <para>在通过sx和sy进行缩放之后，所有坐标都被视为与sx和sy相乘。 绘图操作的每个结果也相应地缩放，例如按（2,2）缩放将意味着在x和y方向上使所有内容都变为两倍。 按负值缩放会使坐标系在相应的方向上翻转，所有内容都会被翻转或颠倒（或两者兼而有之）。 按零缩放没有意义。</para>
            <para>缩放(Scale)操作和平移(Translate)操作不是可交换操作，以不同的顺序调用它们会产生不同的结果。</para>
            <para>效果持续到 Scene.Draw 调用结束（每一帧画面绘制结束都会自动重置为1倍。）</para>
            
            <para>Scales the coordinate system in two dimensions.</para> 
            <para>By default the coordinate system in LÖVE corresponds to the display pixels in horizontal and vertical directions one-to-one, and the x-axis increases towards the right while the y-axis increases downwards. Scaling the coordinate system changes this relation.</para>
            <para>After scaling by sx and sy, all coordinates are treated as if they were multiplied by sx and sy. Every result of a drawing operation is also correspondingly scaled, so scaling by (2, 2) for example would mean making everything twice as large in both x- and y-directions. Scaling by a negative value flips the coordinate system in the corresponding direction, which also means everything will be drawn flipped or upside down, or both. Scaling by zero is not a useful operation.</para>
            <para>Scale and translate are not commutative operations, therefore, calling them in different orders will change the outcome.</para>
            <para>Scaling lasts until Scene.Draw exits.</para>
            </summary>
            <param name="scale">The scaling on each axis.</param>
        </member>
        <member name="F:Love.Graphics.SystemLimit.PointSize">
            <summary>
            The maximum size of points.
            </summary>
        </member>
        <member name="F:Love.Graphics.SystemLimit.TextureSize">
            <summary>
            The maximum width or height of Images and Canvases.
            </summary>
        </member>
        <member name="F:Love.Graphics.SystemLimit.MultiCanvas">
            <summary>
            The maximum number of simultaneously active canvases (via <see cref="M:Love.Graphics.SetCanvas(Love.Canvas[])"/>.)
            </summary>
        </member>
        <member name="F:Love.Graphics.SystemLimit.CanvasMSAA">
            <summary>
            The maximum number of antialiasing samples for a Canvas.
            </summary>
        </member>
        <member name="M:Love.Graphics.NewCanvas(System.Int32,System.Int32,Love.Graphics.Settings)">
            <summary>
            Creates a new Canvas.
            <para>This function can be slow if it is called repeatedly, such as from love.update or love.draw. If you need to use a specific resource often, create it once and store it somewhere it can be reused!</para>
            </summary>
            <param name="width">The desired width of the Canvas.</param>
            <param name="height">The desired height of the Canvas.</param>
            <param name="format_type"></param>
            <param name="msaa"></param>
            <returns>A new Canvas with specified width and height.</returns>
        </member>
        <member name="M:Love.Graphics.NewMesh(System.Int32,Love.MeshDrawMode,Love.SpriteBatchUsage)">
            <summary>
            Creates a standard Mesh with the specified number of vertices.
            </summary>
            <param name="count">The total number of vertices the Mesh will use. Each vertex is initialized to position of (0,0), uv of (0,0), color of (1,1,1,1).</param>
            <param name="drawMode">How the vertices are used when drawing. The default mode "fan" is sufficient for simple convex polygons.</param>
            <param name="usage">The expected usage of the Mesh. The specified usage mode affects the Mesh's memory usage and performance.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.NewVideo(Love.VideoStream,System.Boolean,System.Nullable{System.Single})">
            <summary>
            Creates a new drawable Video. Currently only Ogg Theora video files are supported.
            </summary>
            <param name="videoStream"> a VideoStream object </param>
            <param name="audio">Whether to try to load the video's audio into an audio Source. If not explicitly set to true or false, it will try without causing an error if the video has no audio.</param>
            <param name="dipScale">The DPI scale factor of the video. if it was null, value will be Graphics.GetDPIScale()</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.Reset">
            <summary>
            Resets the current graphics settings.
            <para>Calling reset makes the current drawing color white, the current background color black, disables any active Canvas or Shader, and removes any scissor settings. It sets the BlendMode to alpha, enables all color component masks, disables wireframe mode and resets the current graphics transformation to the origin. It also sets both the point and line drawing modes to smooth and their sizes to 1.0.</para>
            </summary>
        </member>
        <member name="M:Love.Graphics.IsActive">
            <summary>
            Gets whether the graphics module is able to be used.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.IsGammaCorrect">
            <summary>
            Gets whether gamma-correct rendering is enabled.
            <para></para>
            <para>Not all devices support gamma-correct rendering, in which case it will be automatically disabled and this function will return false. It is supported on desktop systems which have graphics cards that are capable of using OpenGL 3 / DirectX 10, and iOS devices that can use OpenGL ES 3.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.SetScissor">
            <summary>
            Disables scissor.
            </summary>
        </member>
        <member name="M:Love.Graphics.SetScissor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets scissor.
            <para>The scissor limits the drawing area to a specified rectangle. This affects all graphics calls, including love.graphics.clear.</para>
            <para>The dimensions of the scissor is unaffected by graphical transformations(translate, scale, ...).</para>
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="w"></param>
            <param name="h"></param>
        </member>
        <member name="M:Love.Graphics.IntersectScissor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            设置 scissor 为所给矩形和现有 scissor 的交集（交集肯定还是个矩形）。如果之前没有设置 scissor，则相当于调用 <see cref="M:Love.Graphics.SetScissor"/> 
            <para>Sets the scissor to the rectangle created by the intersection of the specified rectangle with the existing scissor.</para>
            <para>The scissor limits the drawing area to a specified rectangle. This affects all graphics calls, including love.graphics.clear.</para>
            <para>The dimensions of the scissor is unaffected by graphical transformations(translate, scale, ...).</para>
            </summary>
            <param name="x">x coordinate of upper left corner.</param>
            <param name="y">y coordinate of upper left corner.</param>
            <param name="w">width of clipping rectangle.</param>
            <param name="h">height of clipping rectangle.</param>
        </member>
        <member name="M:Love.Graphics.GetScissor">
            <summary>
            Gets the current scissor box.
            <para> Int4:x The x-component of the top-left point of the box. </para>
            <para> Int4:y The y-component of the top-left point of the box. </para>
            <para> The width of the box. </para>
            <para> The height of the box. </para>
            </summary>
            <returns>
            </returns>
        </member>
        <member name="M:Love.Graphics.SetStencilTest(Love.CompareMode,System.Int32)">
            <summary>
            Configures or disables stencil testing.
            <para>When stencil testing is enabled, the geometry of everything that is drawn afterward will be clipped / stencilled out based on a comparison between the arguments of this function and the stencil value of each pixel that the geometry touches. The stencil values of pixels are affected via Graphics.Stencil.</para>
            </summary>
            <param name="compare_type">The type of comparison to make for each pixel.</param>
            <param name="compareValue">The value to use when comparing with the stencil value of each pixel. </param>
        </member>
        <member name="M:Love.Graphics.GetStencilTest(Love.CompareMode@,System.Int32@)">
            <summary>
            Gets the current stencil test configuration.
            <para>When stencil testing is enabled, the geometry of everything that is drawn afterward will be clipped / stencilled out based on a comparison between the arguments of this function and the stencil value of each pixel that the geometry touches. The stencil values of pixels are affected via Graphics.Stencil.</para>
            <para>Each Canvas has its own per-pixel stencil values.</para>
            </summary>
            <param name="out_compare_type">The type of comparison that is made for each pixel. Will be "always" if stencil testing is disabled.</param>
            <param name="out_compareValue">The value used when comparing with the stencil value of each pixel.</param>
        </member>
        <member name="M:Love.Graphics.SetColor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the color used for drawing.
            </summary>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
        </member>
        <member name="M:Love.Graphics.GetColor">
            <summary>
            Gets the current color.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.SetBackgroundColor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the background color.
            </summary>
            <param name="r">The red component (0-1).</param>
            <param name="g">The green component (0-1).</param>
            <param name="b">The blue component (0-1).</param>
            <param name="a">The alpha component (0-1).</param>
        </member>
        <member name="M:Love.Graphics.GetBackgroundColor">
            <summary>
            Gets the current background color.
            </summary>
        </member>
        <member name="M:Love.Graphics.SetFont(Love.Font)">
            <summary>
            set font used. pass null to use default font
            </summary>
            <param name="font"></param>
        </member>
        <member name="M:Love.Graphics.GetFont">
            <summary>
            Gets the current Font object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.SetColorMask(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Sets the color mask. Enables or disables specific color components when rendering.
            </summary>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
        </member>
        <member name="M:Love.Graphics.GetColorMask(System.Boolean@,System.Boolean@,System.Boolean@,System.Boolean@)">
            <summary>
            Gets the active color components used when drawing. Normally all 4 components are active unless <see cref="M:Love.Graphics.SetColorMask(System.Boolean,System.Boolean,System.Boolean,System.Boolean)"/> has been used.
            <para>The color mask determines whether individual components of the colors of drawn objects will affect the color of the screen. They affect <see cref="M:Love.Graphics.Clear"/> as well.</para>
            </summary>
            <param name="out_r">Whether the red color component is active when rendering.</param>
            <param name="out_g">Whether the red green component is active when rendering.</param>
            <param name="out_b">Whether the red blue component is active when rendering.</param>
            <param name="out_a">Whether the red alpha component is active when rendering.</param>
        </member>
        <member name="M:Love.Graphics.SetBlendMode(Love.BlendMode,Love.BlendAlphaMode)">
            <summary>
            Sets the blending mode.
            </summary>
            <param name="blendMode">The blend mode to use.</param>
            <param name="blendAlphaMode">What to do with the alpha of drawn objects when blending.</param>
        </member>
        <member name="M:Love.Graphics.GetBlendMode(Love.BlendMode@,Love.BlendAlphaMode@)">
            <summary>
            Gets the blending mode.
            </summary>
            <param name="out_blendMode_type">The current blend mode.</param>
            <param name="out_blendAlphaMode_type">The current blend alpha mode – it determines how the alpha of drawn objects affects blending.</param>
        </member>
        <member name="M:Love.Graphics.SetDefaultFilter(Love.FilterMode,Love.FilterMode,System.Int32)">
            <summary>
            Sets the default scaling filters used with Images, Canvases, and Fonts.
            </summary>
            <param name="filterModeMagMin_type">Filter mode used when scaling the image down.</param>
            <param name="filterModeMag_type">Filter mode used when scaling the image up.</param>
            <param name="anisotropy">Maximum amount of Anisotropic Filtering used.</param>
        </member>
        <member name="M:Love.Graphics.GetDefaultFilter(Love.FilterMode@,Love.FilterMode@,System.Int32@)">
            <summary>
            Returns the default scaling filters used with Images, Canvases, and Fonts.
            </summary>
            <param name="out_filterModeMagMin_type">Filter mode used when scaling the image down.</param>
            <param name="out_filterModeMag_type">Filter mode used when scaling the image up.</param>
            <param name="out_anisotropy">Maximum amount of Anisotropic Filtering used.</param>
        </member>
        <member name="M:Love.Graphics.SetLineWidth(System.Single)">
            <summary>
            Sets the line width.
            </summary>
            <param name="width"></param>
        </member>
        <member name="M:Love.Graphics.SetLineStyle(Love.LineStyle)">
            <summary>
            Sets the line style.
            </summary>
            <param name="style_type"></param>
        </member>
        <member name="M:Love.Graphics.SetLineJoin(Love.LineJoin)">
            <summary>
            Sets the line join style.
            </summary>
            <param name="join_type"></param>
        </member>
        <member name="M:Love.Graphics.GetLineWidth">
            <summary>
            Gets the current line width.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.GetLineStyle">
            <summary>
            Gets the line style.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.GetLineJoin">
            <summary>
            Gets the line join style.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.SetPointSize(System.Single)">
            <summary>
            Sets the point size.
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:Love.Graphics.GetPointSize">
            <summary>
            Gets the point size.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.IsWireframe">
            <summary>
            是否使用线框模式绘图
            Gets whether wireframe mode is used when drawing.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.SetCanvas(Love.Canvas[])">
            <summary>
            Captures drawing operations to a Canvas
            <para>Sets the render target to a specified Canvas. All drawing operations until the next love.graphics.setCanvas call will be redirected to the Canvas and not shown on the screen.</para>
            <para>if Length of canvas is zero, then resets the render target to the screen, i.e. re-enables drawing to the screen.</para>
            </summary>
            <param name="canvas"></param>
        </member>
        <member name="M:Love.Graphics.GetCanvas">
            <summary>
            Returns the current target Canvas. Returns zero length array if drawing to the real screen.
            </summary>
        </member>
        <member name="M:Love.Graphics.SetShader(Love.Shader)">
            <summary>
            Routes drawing operations through a shader.
            </summary>
            <param name="shader"></param>
        </member>
        <member name="M:Love.Graphics.SetShader">
            <summary>
            Disables shaders, allowing unfiltered drawing operations.
            </summary>
        </member>
        <member name="M:Love.Graphics.GetShader">
            <summary>
            Gets the current Shader. Returns null if none is set.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.Push(Love.StackType)">
            <summary>
            Copies and pushes the current coordinate transformation to the transformation stack.
            </summary>
            <param name="stack"></param>
        </member>
        <member name="M:Love.Graphics.Pop">
            <summary>
            Pops the current coordinate transformation from the transformation stack.
            This function is always used to reverse a previous <see cref="M:Love.Graphics.Push(Love.StackType)"/> operation. It returns the current transformation state to what it was before the last preceding push.
            </summary>
        </member>
        <member name="M:Love.Graphics.Rotate(System.Single)">
            <summary>
            Rotates the coordinate system in two dimensions.
            <para>Calling this function affects all future drawing operations by rotating the coordinate system around the origin by the given amount of radians. This change lasts until Scene.Draw exits.</para>
            </summary>
            <param name="angle">The amount to rotate the coordinate system in radians.</param>
        </member>
        <member name="M:Love.Graphics.Scale(System.Single,System.Single)">
            <summary>
            <para>以二维方式缩放坐标系。</para>
            <para>默认情况下，LÖVE中的坐标系在水平和垂直方向上一对一显示像素，x轴向右增加，y轴向下增加。 缩放坐标系会改变这种关系。</para>
            <para>在通过sx和sy进行缩放之后，所有坐标都被视为与sx和sy相乘。 绘图操作的每个结果也相应地缩放，例如按（2,2）缩放将意味着在x和y方向上使所有内容都变为两倍。 按负值缩放会使坐标系在相应的方向上翻转，所有内容都会被翻转或颠倒（或两者兼而有之）。 按零缩放没有意义。</para>
            <para>缩放(Scale)操作和平移(Translate)操作不是可交换操作，以不同的顺序调用它们会产生不同的结果。</para>
            <para>效果持续到 Scene.Draw 调用结束（每一帧画面绘制结束都会自动重置为1倍。）</para>
            
            <para>Scales the coordinate system in two dimensions.</para> 
            <para>By default the coordinate system in LÖVE corresponds to the display pixels in horizontal and vertical directions one-to-one, and the x-axis increases towards the right while the y-axis increases downwards. Scaling the coordinate system changes this relation.</para>
            <para>After scaling by sx and sy, all coordinates are treated as if they were multiplied by sx and sy. Every result of a drawing operation is also correspondingly scaled, so scaling by (2, 2) for example would mean making everything twice as large in both x- and y-directions. Scaling by a negative value flips the coordinate system in the corresponding direction, which also means everything will be drawn flipped or upside down, or both. Scaling by zero is not a useful operation.</para>
            <para>Scale and translate are not commutative operations, therefore, calling them in different orders will change the outcome.</para>
            <para>Scaling lasts until Scene.Draw exits.</para>
            </summary>
            <param name="sx">The scaling in the direction of the x-axis.</param>
            <param name="sy">The scaling in the direction of the y-axis.</param>
        </member>
        <member name="M:Love.Graphics.Translate(System.Single,System.Single)">
            <summary>
            Translates the coordinate system in two dimensions.
            <para>When this function is called with two numbers, dx, and dy, all the following drawing operations take effect as if their x and y coordinates were x+dx and y+dy.</para>
            <para>Scale and translate are not commutative operations, therefore, calling them in different orders will change the outcome.</para>
            <para>This change lasts until Scene.Draw exits or else a <see cref="M:Love.Graphics.Pop"/> reverts to a previous <see cref="M:Love.Graphics.Push(Love.StackType)"/> .</para>
            <para>Translating using whole numbers will prevent tearing/blurring of images and fonts draw after translating.</para>
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Love.Graphics.Shear(System.Single,System.Single)">
            <summary>
            Shears the coordinate system.
            </summary>
            <param name="kx"></param>
            <param name="ky"></param>
        </member>
        <member name="M:Love.Graphics.Origin">
            <summary>
            Resets the current coordinate transformation.
            </summary>
        </member>
        <member name="M:Love.Graphics.Stencil(System.Action,Love.StencilAction,System.Int32,System.Boolean)">
            <summary>
            Draws geometry as a stencil.
            <para> The geometry drawn by the supplied function sets invisible stencil values of pixels, instead of setting pixel colors. The stencil buffer (which contains those stencil values) can act like a mask / stencil - love.graphics.setStencilTest can be used afterward to determine how further rendering is affected by the stencil values in each pixel.</para>
            <para> Stencil values are integers within the range of [0, 255].</para>
            <para> Starting with version 11.0, a stencil buffer must be set or requested in love.graphics.setCanvas when using stencils with a Canvas. love.graphics.setCanvas{canvas, stencil=true} is an easy way to use an automatically provided temporary stencil buffer in that case.</para>
            https://love2d.org/wiki/love.graphics.stencil
            </summary>
            <param name="actionFunc">Function which draws geometry. The stencil values of pixels, rather than the color of each pixel, will be affected by the geometry.</param>
            <param name="stencilAction">How to modify any stencil values of pixels that are touched by what's drawn in the stencil function.</param>
            <param name="value">The new stencil value to use for pixels if the "replace" stencil action is used. Has no effect with other stencil actions. Must be between 0 and 255.</param>
            <param name="keepValue">True to preserve old stencil values of pixels, false to re-set every pixel's stencil value to 0 before executing the stencil function. love.graphics.clear will also re-set all stencil values.</param>
        </member>
        <member name="M:Love.Graphics.Discard(System.Boolean[],System.Boolean)">
            <summary>
            Discards (trashes) the contents of the screen or active Canvas. This is a performance optimization function with niche use cases.
            </summary>
            <param name="discardColors">An array containing boolean values indicating whether to discard the texture of each active Canvas, when multiple simultaneous Canvases are active.</param>
            <param name="discardStencil">Whether to discard the contents of the stencil buffer of the screen / active Canvas.</param>
        </member>
        <member name="M:Love.Graphics.Present">
            <summary>
            Displays the results of drawing operations on the screen.
            This function is used when writing your own Boot.Run function. It presents all the results of your drawing operations on the screen. See the example in Boot.Run for a typical use of this function.
            </summary>
        </member>
        <member name="M:Love.Graphics.Draw(Love.Drawable,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Draws a Drawable object (an Image, Canvas, SpriteBatch, ParticleSystem, Mesh, Text object, or Video) on the screen with optional rotation, scaling and shearing.
            </summary>
            <param name="drawable">A drawable object.</param>
            <param name="x">The position to draw the object (x-axis).</param>
            <param name="y">The position to draw the object (y-axis).</param>
            <param name="angle">Orientation (radians).</param>
            <param name="sx">Scale factor (x-axis).</param>
            <param name="sy">Scale factor (y-axis).</param>
            <param name="ox">Origin offset (x-axis).</param>
            <param name="oy">Origin offset (y-axis).</param>
            <param name="kx">Shearing factor (x-axis).</param>
            <param name="ky">Shearing factor (y-axis).</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.Print(System.String,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Draws text on screen. If no Font is set, one will be created and set (once) if needed.
            As of LOVE 0.7.1, when using translation and scaling functions while drawing text, this function assumes the scale occurs first. If you don't script with this in mind, the text won't be in the right position, or possibly even on screen.
            Love.Graphics.Print and Love.Graphics.Printf both support UTF-8 encoding. You'll also need a proper Font for special characters.
            </summary>
            <param name="text">The text to draw.</param>
            <param name="x">The position to draw the object (x-axis).</param>
            <param name="y">The position to draw the object (y-axis).</param>
            <param name="angle">Orientation (radians).</param>
            <param name="sx">Scale factor (x-axis).</param>
            <param name="sy">Scale factor (y-axis).</param>
            <param name="ox">Origin offset (x-axis).</param>
            <param name="oy">Origin offset (y-axis).</param>
            <param name="kx">Shearing factor (x-axis).</param>
            <param name="ky">Shearing factor (y-axis).</param>
        </member>
        <member name="M:Love.Graphics.Print(Love.ColoredStringArray,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Same as Love.Graphics.Print(string...), but coloredStr used to show text in different color.
            </summary>
            <param name="coloredStr">colors and strings </param>
        </member>
        <member name="M:Love.Graphics.Rectangle(Love.DrawMode,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Draws a rectangle.
            </summary>
            <param name="mode_type">How to draw the rectangle.</param>
            <param name="x">The position of top-left corner along the x-axis.</param>
            <param name="y">The position of top-left corner along the y-axis.</param>
            <param name="w">Width of the rectangle.</param>
            <param name="h">Height of the rectangle.</param>
        </member>
        <member name="M:Love.Graphics.Rectangle(Love.DrawMode,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Draws a rectangle with rounded corners.
            </summary>
            <param name="mode_type">How to draw the rectangle.</param>
            <param name="x">The position of top-left corner along the x-axis.</param>
            <param name="y">The position of top-left corner along the y-axis.</param>
            <param name="w">Width of the rectangle.</param>
            <param name="h">Height of the rectangle.</param>
            <param name="rx">The x-axis radius of each round corner. Cannot be greater than half the rectangle's width.</param>
            <param name="ry">The y-axis radius of each round corner. Cannot be greater than half the rectangle's height.</param>
            <param name="points">The number of segments used for drawing the round corners. A default amount will be chosen if no number is given.</param>
        </member>
        <member name="M:Love.Graphics.Circle(Love.DrawMode,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Draws a circle.
            </summary>
            <param name="mode_type">How to draw the circle.</param>
            <param name="x">The position of the center along x-axis.</param>
            <param name="y">The position of the center along y-axis.</param>
            <param name="radius">The radius of the circle.</param>
            <param name="points">The number of segments used for drawing the circle. Note: The default variable for the segments parameter varies between different versions of LÖVE.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.Ellipse(Love.DrawMode,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Draws an ellipse.
            </summary>
            <param name="mode_type">How to draw the ellipse.</param>
            <param name="x">he position of the center along x-axis.</param>
            <param name="y">he position of the center along y-axis.</param>
            <param name="radiusX">The radius of the ellipse along the x-axis (half the ellipse's width).</param>
            <param name="radiusY">The radius of the ellipse along the y-axis (half the ellipse's height).</param>
            <param name="points">The number of segments used for drawing the ellipse.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.Points(Love.Vector2[])">
            <summary>
            Draws one or more points.
            </summary>
            <param name="coords">The position of the each point</param>
        </member>
        <member name="M:Love.Graphics.Line(Love.Vector2[])">
            <summary>
            Draws lines between points.
            </summary>
            <param name="coords">A array of point positions.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.Polygon(Love.DrawMode,Love.Vector2[])">
            <summary>
            Draw a polygon.
            When in fill mode, the polygon must be convex and simple or rendering artifacts may occur. Love.Mathf.Triangulate and Love.Mathf.IsConvex can be used in 0.9.0+.
            </summary>
            <param name="mode_type">How to draw the polygon.</param>
            <param name="coords">The vertices of the polygon.</param>
        </member>
        <member name="M:Love.Graphics.GetDPIScale">
            <summary>
            Gets the DPI scale factor of the window.
            <para>The DPI scale factor represents relative pixel density. The pixel density inside the window might be greater (or smaller) than the "size" of the window. For example on a retina screen in Mac OS X with the highdpi window flag enabled, the window may take up the same physical size as an 800x600 window, but the area inside the window uses 1600x1200 pixels. love.graphics.getDPIScale() would return 2 in that case.</para>
            <para>The love.window.fromPixels and love.window.toPixels functions can also be used to convert between units.</para>
            <para>The highdpi window flag must be enabled to use the full pixel density of a Retina screen on Mac OS X and iOS. The flag currently does nothing on Windows and Linux, and on Android it is effectively always enabled.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.GetWidth">
            <summary>
            Gets the width in pixels of the window.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.GetHeight">
            <summary>
            Gets the height in pixels of the window.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.GetSupported(Love.Feature)">
            <summary>
            Gets the optional graphics features and whether they're supported.
            </summary>
            <param name="feature_type"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.GetCanvasFormats(Love.PixelFormat)">
            <summary>
            Gets the available Canvas formats, and whether each is supported.
            </summary>
            <param name="format_type"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.GetRendererInfo(System.String@,System.String@,System.String@,System.String@)">
            <summary>
            Gets information about the system's video card and drivers.
            <para> Almost everything returned by this function is highly dependent on the system running the code and should probably not be used to make run-time decisions</para>
            </summary>
            <param name="name">The name of the renderer, e.g. "OpenGL" or "OpenGL ES".</param>
            <param name="version">The version of the renderer with some extra driver-dependent version info, e.g. "2.1 INTEL-8.10.44".</param>
            <param name="vendor">The name of the graphics card vendor, e.g. "Intel Inc".</param>
            <param name="device">The name of the graphics card, e.g. "Intel HD Graphics 3000 OpenGL Engine".</param>
        </member>
        <member name="M:Love.Graphics.GetSystemLimits(Love.Graphics.SystemLimit)">
            <summary>
            Gets the system-dependent maximum values for love.graphics features.
            </summary>
            <param name="limit_type"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Graphics.GetStats(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Gets performance-related rendering statistics.
            <para>	The per-frame metrics (drawcalls, canvasswitches, shaderswitches) are reset by love.graphics.present, which for the default implementation of <see cref="M:Love.Boot.Run(Love.Scene,Love.BootConfig)"/> is called right after the execution of Scene.Draw. Therefore this function should probably be called at the end of Scene.Draw.</para>
            </summary>
            <param name="out_drawCalls">The number of draw calls made so far during the current frame.</param>
            <param name="out_canvasSwitches">The number of times the active Canvas has been switched so far during the current frame.</param>
            <param name="out_shaderSwitches">The number of times the active Shader has been changed so far during the current frame.</param>
            <param name="out_canvases">The number of Canvas objects currently loaded.</param>
            <param name="out_images">The number of Image objects currently loaded.</param>
            <param name="out_fonts">The number of Font objects currently loaded.</param>
            <param name="out_textureMemory">The estimated total size in bytes of video memory used by all loaded Images, Canvases, and Fonts.</param>
        </member>
        <member name="T:Love.ParticleSystem">
            <summary>
            A ParticleSystem can be used to create particle effects like fire or smoke.
            <para>The particle system has to be created using <see cref="M:Love.Graphics.NewParticleSystem(Love.Texture,System.Int32)"/>. Just like any other <see cref="T:Love.Drawable"/> it can be drawn to the screen using love.graphics.draw. You also have to call <see cref="M:Love.ParticleSystem.Update(System.Single)"/> in the update callback to see any changes in the particles emitted.</para>
            <para>The particle system won't create any particles unless you call <see cref="M:Love.ParticleSystem.SetParticleLifetime(System.Single,System.Single)"/> and <see cref="M:Love.ParticleSystem.SetEmissionRate(System.Single)"/>.</para>
            </summary>
        </member>
        <member name="M:Love.ParticleSystem.GetOffset">
            <summary>
            Get the offset position which the particle sprite is rotated around. If this function is not used, the particles rotate around their center.
            </summary>
            <returns>The coordinate of the rotation offset.</returns>
        </member>
        <member name="M:Love.ParticleSystem.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.ParticleSystem.Clone">
            <summary>
            Creates an identical copy of the ParticleSystem in the stopped state.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.ParticleSystem.SetTexture(Love.Texture)">
            <summary>
            Sets the texture (Image or Canvas) to be used for the particles.
            </summary>
            <param name="texture">An Image or Canvas to use for the particles.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetTexture">
            <summary>
            Gets the texture (Image or Canvas) used for the particles.
            </summary>
            <returns>The Image or Canvas used for the particles.</returns>
        </member>
        <member name="M:Love.ParticleSystem.SetBufferSize(System.UInt32)">
            <summary>
            Sets the size of the buffer (the max allowed amount of particles in the system).
            </summary>
            <param name="buffersize">The buffer size.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetBufferSize">
            <summary>
            Gets the maximum number of particles the ParticleSystem can have at once.
            </summary>
            <returns>The maximum number of particles.</returns>
        </member>
        <member name="M:Love.ParticleSystem.SetInsertMode(Love.ParticleInsertMode)">
            <summary>
            Sets the mode to use when the ParticleSystem adds new particles.
            </summary>
            <param name="mode_type">The mode to use when the ParticleSystem adds new particles.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetInsertMode">
            <summary>
            Gets the mode used when the ParticleSystem adds new particles.
            </summary>
            <returns>The mode used when the ParticleSystem adds new particles.</returns>
        </member>
        <member name="M:Love.ParticleSystem.SetEmissionRate(System.Single)">
            <summary>
            Sets the amount of particles emitted per second.
            </summary>
            <param name="rate">The amount of particles per second.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetEmissionRate">
            <summary>
            Gets the amount of particles emitted per second.
            </summary>
            <returns>The amount of particles per second.</returns>
        </member>
        <member name="M:Love.ParticleSystem.SetEmitterLifetime(System.Single)">
            <summary>
            Sets how long the particle system should emit particles (if -1 then it emits particles forever).
            </summary>
            <param name="lifetime">The lifetime of the emitter (in seconds).</param>
        </member>
        <member name="M:Love.ParticleSystem.GetEmitterLifetime">
            <summary>
            Gets how long the particle system will emit particles (if -1 then it emits particles forever).
            </summary>
            <returns>The lifetime of the emitter (in seconds).</returns>
        </member>
        <member name="M:Love.ParticleSystem.SetParticleLifetime(System.Single,System.Single)">
            <summary>
            Sets the lifetime of the particles.
            </summary>
            <param name="min">The minimum life of the particles (in seconds).</param>
            <param name="max">The maximum life of the particles (in seconds).</param>
        </member>
        <member name="M:Love.ParticleSystem.GetParticleLifetime(System.Int32@,System.Int32@)">
            <summary>
            Gets the lifetime of the particles.
            </summary>
            <param name="out_min">The minimum life of the particles (in seconds).</param>
            <param name="out_max">The maximum life of the particles (in seconds).</param>
        </member>
        <member name="M:Love.ParticleSystem.SetPosition(System.Single,System.Single)">
            <summary>
            Sets the position of the emitter.
            </summary>
            <param name="x">Position along x-axis.</param>
            <param name="y">Position along y-axis.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetPosition">
            <summary>
            Gets the position of the emitter.
            </summary>
            <returns>Position of the emitter.</returns>
        </member>
        <member name="M:Love.ParticleSystem.MoveTo(System.Single,System.Single)">
            <summary>
            Moves the position of the emitter.
            This results in smoother particle spawning behaviour than if ParticleSystem.SetPosition is used every frame.
            </summary>
            <param name="x">Position along x-axis.</param>
            <param name="y">Position along y-axis.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetAreaSpread(Love.AreaSpreadDistribution@,System.Single@,System.Single@)">
            <summary>
            Gets the area-based spawn parameters for the particles.
            </summary>
            <param name="out_distribution_type">The type of distribution for new particles.</param>
            <param name="out_x"></param>
            <param name="out_y"></param>
        </member>
        <member name="M:Love.ParticleSystem.SetEmissionArea(Love.AreaSpreadDistribution,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            Sets area-based spawn parameters for the particles. Newly created particles will spawn in an area around the emitter based on the parameters to this function.
            </summary>
            <param name="distribution">The type of distribution for new particles.</param>
            <param name="dx">The maximum spawn distance from the emitter along the x-axis for uniform distribution, or the standard deviation along the x-axis for normal distribution.</param>
            <param name="dy">The maximum spawn distance from the emitter along the y-axis for uniform distribution, or the standard deviation along the y-axis for normal distribution.</param>
            <param name="angle">The angle in radians of the emission area.</param>
            <param name="directionRelativeToCenter">True if newly spawned particles will be oriented relative to the center of the emission area, false otherwise.</param>
        </member>
        <member name="M:Love.ParticleSystem.SetDirection(System.Single)">
            <summary>
            Sets the direction the particles will be emitted in.
            </summary>
            <param name="direction">The direction of the particles(in radians).</param>
        </member>
        <member name="M:Love.ParticleSystem.GetDirection">
            <summary>
            Gets the direction of the particle emitter (in radians).
            </summary>
            <returns>The direction of the emitter (radians).</returns>
        </member>
        <member name="M:Love.ParticleSystem.SetSpread(System.Single)">
            <summary>
            Sets the amount of spread for the system.
            </summary>
            <param name="spread">The amount of spread (radians).</param>
        </member>
        <member name="M:Love.ParticleSystem.GetSpread">
            <summary>
            Gets the amount of directional spread of the particle emitter (in radians).
            </summary>
            <returns>The spread of the emitter (radians).</returns>
        </member>
        <member name="M:Love.ParticleSystem.SetSpeed(System.Single,System.Single)">
            <summary>
            Sets the speed of the particles.
            </summary>
            <param name="min">The minimum linear speed of the particles.</param>
            <param name="max">The maximun linear speed of the particles.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetSpeed(System.Single@,System.Single@)">
            <summary>
            Gets the speed of the particles.
            </summary>
            <param name="out_min">The minimum linear speed of the particles.</param>
            <param name="out_max">The maximum linear speed of the particles.</param>
        </member>
        <member name="M:Love.ParticleSystem.SetLinearAcceleration(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the linear acceleration (acceleration along the x and y axes) for particles.
            <para>Every particle created will accelerate along the x and y axes between xmin,ymin and xmax,ymax.</para>
            </summary>
            <param name="xmin">The minimum acceleration along the x axis.</param>
            <param name="ymin">The minimum acceleration along the y axis.</param>
            <param name="xmax">The maximum acceleration along the x axis.</param>
            <param name="ymax">The maximum acceleration along the y axis.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetLinearAcceleration(System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Gets the linear acceleration (acceleration along the x and y axes) for particles.
            <para>Every particle created will accelerate along the x and y axes between xmin,ymin and xmax,ymax.</para>
            </summary>
            <param name="out_xmin">The minimum acceleration along the x axis.</param>
            <param name="out_ymin">The minimum acceleration along the y axis.</param>
            <param name="out_xmax">The maximum acceleration along the x axis.</param>
            <param name="out_ymax">The maximum acceleration along the y axis.</param>
        </member>
        <member name="M:Love.ParticleSystem.SetRadialAcceleration(System.Single,System.Single)">
            <summary>
            Set the radial acceleration (away from the emitter).
            </summary>
            <param name="min">The minimum acceleration.</param>
            <param name="max">The maximum acceleration.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetRadialAcceleration(System.Int32@,System.Int32@)">
            <summary>
            Gets the radial acceleration (away from the emitter).
            </summary>
            <param name="out_min">The minimum acceleration.</param>
            <param name="out_max">The maximum acceleration.</param>
        </member>
        <member name="M:Love.ParticleSystem.SetTangentialAcceleration(System.Single,System.Single)">
            <summary>
            Sets the tangential acceleration (acceleration perpendicular to the particle's direction).
            </summary>
            <param name="min">The minimum acceleration.</param>
            <param name="max">The maximum acceleration.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetTangentialAcceleration(System.Int32@,System.Int32@)">
            <summary>
            Gets the tangential acceleration (acceleration perpendicular to the particle's direction).
            </summary>
            <param name="out_min">The minimum acceleration.</param>
            <param name="out_max">The maximum acceleration.</param>
        </member>
        <member name="M:Love.ParticleSystem.SetLinearDamping(System.Single,System.Single)">
            <summary>
            Sets the amount of linear damping (constant deceleration) for particles.
            </summary>
            <param name="min">The minimum amount of linear damping applied to particles.</param>
            <param name="max">The maximum amount of linear damping applied to particles.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetLinearDamping(System.Int32@,System.Int32@)">
            <summary>
            Gets the amount of linear damping (constant deceleration) for particles.
            </summary>
            <param name="out_min">The minimum amount of linear damping applied to particles.</param>
            <param name="out_max">The maximum amount of linear damping applied to particles.</param>
        </member>
        <member name="M:Love.ParticleSystem.SetSizes(System.Single[])">
            <summary>
            Sets a series of sizes by which to scale a particle sprite. 1.0 is normal size. The particle system will interpolate between each size evenly over the particle's lifetime.
            <para>At least one size must be specified.A maximum of eight may be used.</para>
            </summary>
            <param name="sizeArray">The size array.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetSizes">
            <summary>
            Gets the series of sizes by which the sprite is scaled. 1.0 is normal size. The particle system will interpolate between each size evenly over the particle's lifetime.
            </summary>
            <returns>The size array.</returns>
        </member>
        <member name="M:Love.ParticleSystem.SetSizeVariation(System.Single)">
            <summary>
            Sets the amount of size variation (0 meaning no variation and 1 meaning full variation between start and end).
            </summary>
            <param name="variation">The amount of variation (0 meaning no variation and 1 meaning full variation between start and end).</param>
        </member>
        <member name="M:Love.ParticleSystem.GetSizeVariation">
            <summary>
            Gets the amount of size variation (0 meaning no variation and 1 meaning full variation between start and end).
            </summary>
            <returns>The amount of variation (0 meaning no variation and 1 meaning full variation between start and end).</returns>
        </member>
        <member name="M:Love.ParticleSystem.SetRotation(System.Single,System.Single)">
            <summary>
            Sets the rotation of the image upon particle creation (in radians).
            </summary>
            <param name="min">The minimum initial angle (radians).</param>
            <param name="max">The maximum initial angle (radians).</param>
        </member>
        <member name="M:Love.ParticleSystem.GetRotation(System.Int32@,System.Int32@)">
            <summary>
            Gets the rotation of the image upon particle creation (in radians).
            </summary>
            <param name="out_min">The minimum initial angle (radians).</param>
            <param name="out_max">The maximum initial angle (radians).</param>
        </member>
        <member name="M:Love.ParticleSystem.SetSpin(System.Single,System.Single)">
            <summary>
            Sets the spin of the sprite.
            </summary>
            <param name="start">The minimum spin (radians per second).</param>
            <param name="end">The maximum spin (radians per second).</param>
        </member>
        <member name="M:Love.ParticleSystem.GetSpin(System.Single@,System.Single@)">
            <summary>
            Gets the spin of the sprite.
            </summary>
            <param name="out_start">The minimum spin (radians per second).</param>
            <param name="out_end">The maximum spin (radians per second).</param>
        </member>
        <member name="M:Love.ParticleSystem.SetSpinVariation(System.Single)">
            <summary>
            Sets the amount of spin variation (0 meaning no variation and 1 meaning full variation between start and end).
            </summary>
            <param name="variation">The amount of variation (0 meaning no variation and 1 meaning full variation between start and end).</param>
        </member>
        <member name="M:Love.ParticleSystem.GetSpinVariation">
            <summary>
            Gets the amount of spin variation (0 meaning no variation and 1 meaning full variation between start and end).
            </summary>
            <returns>The amount of variation (0 meaning no variation and 1 meaning full variation between start and end).</returns>
        </member>
        <member name="M:Love.ParticleSystem.SetOffset(System.Single,System.Single)">
            <summary>
            Set the offset position which the particle sprite is rotated around. If this function is not used, the particles rotate around their center.
            </summary>
            <param name="x">The x coordinate of the rotation offset.</param>
            <param name="y">The y coordinate of the rotation offset.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetOffset(System.Single@,System.Single@)">
            <summary>
            Get the offset position which the particle sprite is rotated around. If this function is not used, the particles rotate around their center.
            </summary>
            <param name="out_x">The x coordinate of the rotation offset.</param>
            <param name="out_y">The y coordinate of the rotation offset.</param>
        </member>
        <member name="M:Love.ParticleSystem.SetColors(Love.Vector4[])">
            <summary>
            <para>Sets a series of colors to apply to the particle sprite. The particle system will interpolate between each color evenly over the particle's lifetime.</para>
            <para>Arguments can be passed in groups of four, representing the components of the desired RGBA value, or as tables of RGBA component values, with a default alpha value of 1 if only three values are given. At least one color must be specified. A maximum of eight may be used.</para>
            </summary>
            <param name="colorArray"></param>
        </member>
        <member name="M:Love.ParticleSystem.GetColors">
            <summary>
            Gets the series of colors applied to the particle sprite.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.ParticleSystem.SetQuads(Love.Quad[])">
            <summary>
            Sets a series of Quads to use for the particle sprites. Particles will choose a Quad from the list based on the particle's current lifetime, allowing for the use of animated sprite sheets with ParticleSystems.
            </summary>
            <param name="quads">The Quads to use.</param>
        </member>
        <member name="M:Love.ParticleSystem.GetQuads">
            <summary>
            Gets the series of Quads used for the particle sprites.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.ParticleSystem.SetRelativeRotation(System.Boolean)">
            <summary>
            Sets whether particle angles and rotations are relative to their velocities. If enabled, particles are aligned to the angle of their velocities and rotate relative to that angle.
            </summary>
            <param name="enable">True to enable relative particle rotation, false to disable it.</param>
        </member>
        <member name="M:Love.ParticleSystem.HasRelativeRotation">
            <summary>
            Gets whether particle angles and rotations are relative to their velocities. If enabled, particles are aligned to the angle of their velocities and rotate relative to that angle.
            </summary>
            <returns>True if relative particle rotation is enabled, false if it's disabled.</returns>
        </member>
        <member name="M:Love.ParticleSystem.GetCount">
            <summary>
            Gets the number of particles that are currently in the system.
            </summary>
            <returns>The current number of live particles.</returns>
        </member>
        <member name="M:Love.ParticleSystem.Start">
            <summary>
            Starts the particle emitter.
            </summary>
        </member>
        <member name="M:Love.ParticleSystem.Stop">
            <summary>
            Stops the particle emitter, resetting the lifetime counter.
            </summary>
        </member>
        <member name="M:Love.ParticleSystem.Pause">
            <summary>
            Pauses the particle emitter.
            </summary>
        </member>
        <member name="M:Love.ParticleSystem.Reset">
            <summary>
            Resets the particle emitter, removing any existing particles and resetting the lifetime counter.
            </summary>
        </member>
        <member name="M:Love.ParticleSystem.Emit(System.Int32)">
            <summary>
            Emits a burst of particles from the particle emitter.
            </summary>
            <param name="num">The amount of particles to emit. The number of emitted particles will be truncated if the particle system's max buffer size is reached.</param>
        </member>
        <member name="M:Love.ParticleSystem.IsActive">
            <summary>
            Checks whether the particle system is actively emitting particles.
            </summary>
            <returns>True if system is active, false otherwise.</returns>
        </member>
        <member name="M:Love.ParticleSystem.IsPaused">
            <summary>
            Checks whether the particle system is paused.
            </summary>
            <returns>True if system is paused, false otherwise.</returns>
        </member>
        <member name="M:Love.ParticleSystem.IsStopped">
            <summary>
            Checks whether the particle system is stopped.
            </summary>
            <returns>True if system is stopped, false otherwise.</returns>
        </member>
        <member name="M:Love.ParticleSystem.Update(System.Single)">
            <summary>
            Updates the particle system; moving, creating and killing particles.
            </summary>
            <param name="dt">The time (seconds) since last frame.</param>
        </member>
        <member name="T:Love.Quad">
            <summary>
            A quadrilateral (a polygon with four sides and four corners) with texture coordinate information.
            <para>Quads can be used to select part of a texture to draw. In this way, one large texture atlas can be loaded, and then split up into sub-images.</para>
            <para>Quads 'bleed' when scaled, rotated or drawn at non-integer coordinates, even within SpriteBatches, to compensate for this, use 1px borders around the textures inside the texture atlas (preferably with the same colors as the actual border)</para>
            </summary>
        </member>
        <member name="M:Love.Quad.GetViewport">
            <summary>
            Gets the texture coordinates according to a viewport.
            </summary>
            <returns>The size of the viewport</returns>
        </member>
        <member name="M:Love.Quad.GetTextureDimensions">
            <summary>
            Gets reference texture dimensions initially specified in love.graphics.newQuad.
            </summary>
            <returns>The Texture size used by the Quad.</returns>
        </member>
        <member name="M:Love.Quad.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Quad.SetViewport(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the texture coordinates according to a viewport.
            </summary>
            <param name="x">The top-left corner along the x-axis.</param>
            <param name="y">The top-right corner along the y-axis.</param>
            <param name="w">The width of the viewport.</param>
            <param name="h">The height of the viewport.</param>
        </member>
        <member name="M:Love.Quad.GetViewport(System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Gets the texture coordinates according to a viewport.
            </summary>
            <param name="out_x">The top-left corner along the x-axis.</param>
            <param name="out_y">The top-right corner along the y-axis.</param>
            <param name="out_w">The width of the viewport.</param>
            <param name="out_h">The height of the viewport.</param>
        </member>
        <member name="M:Love.Quad.GetTextureDimensions(System.Single@,System.Single@)">
            <summary>
            Gets reference texture dimensions initially specified in love.graphics.newQuad.
            </summary>
            <returns>The Texture size used by the Quad.</returns>
        </member>
        <member name="T:Love.File">
            <summary>
            <para>Represents a file on the filesystem. A function that takes a file path can also take a <see cref="T:Love.File"/>.</para>
            </summary>
        </member>
        <member name="M:Love.File.Write(System.Byte[])">
            <summary>
            Write data to a file.
            </summary>
            <param name="data"></param>
            <returns>Whether the operation was successful.</returns>
        </member>
        <member name="M:Love.File.Write(Love.Data)">
            <summary>
            Write data to a file.
            </summary>
            <param name="data">The Data object to write.</param>
            <returns>Whether the operation was successful.</returns>
        </member>
        <member name="M:Love.File.#ctor">
            <summary>
            disable no-param construct
            </summary>
        </member>
        <member name="M:Love.File.GetSize">
            <summary>
            Returns the file size(in byte).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.File.Open(Love.FileMode)">
            <summary>
            Open the file for write, read or append.
            </summary>
            <param name="mode_type">The mode to open the file in.</param>
        </member>
        <member name="M:Love.File.Close">
            <summary>
            Closes a File.
            </summary>
            <returns>Whether closing was successful.</returns>
        </member>
        <member name="M:Love.File.IsOpen">
            <summary>
            Gets whether the file is open.
            </summary>
            <returns>True if the file is currently open, false otherwise.</returns>
        </member>
        <member name="M:Love.File.Read(System.Int64)">
            <summary>
            Read a number of bytes from a file
            </summary>
            <param name="size">The number of bytes to read.</param>
            <returns></returns>
        </member>
        <member name="M:Love.File.Write(System.Byte[],System.Int64)">
            <summary>
            Write data to a file.
            </summary>
            <param name="data">The byte data to write.</param>
            <param name="datasize">How many bytes to write.</param>
            <returns>Whether the operation was successful.</returns>
        </member>
        <member name="M:Love.File.Write(Love.Data,System.Int64)">
            <summary>
            Write data to a file.
            </summary>
            <param name="data">The Data object to write.</param>
            <param name="datasize">How many bytes to write.</param>
            <returns>Whether the operation was successful.</returns>
        </member>
        <member name="M:Love.File.Flush">
            <summary>
            Flushes any buffered written data in the file to disk.
            </summary>
        </member>
        <member name="M:Love.File.IsEOF">
            <summary>
            Gets whether end-of-file has been reached.
            </summary>
            <returns>Whether EOF has been reached.</returns>
        </member>
        <member name="M:Love.File.Tell">
            <summary>
            Returns the position in the file.
            </summary>
            <returns>The current position.</returns>
        </member>
        <member name="M:Love.File.Seek(System.Int64)">
            <summary>
            Seek to a position in a file
            </summary>
            <param name="pos">The position to seek to</param>
            <returns>Whether the operation was successful</returns>
        </member>
        <member name="M:Love.File.SetBuffer(Love.BufferMode,System.Int64)">
            <summary>
            <para>Sets the buffer mode for a file opened for writing or appending. Files with buffering enabled will not write data to the disk until the buffer size limit is reached, depending on the buffer mode.</para>
            <para><see cref="M:Love.File.Flush"/> will force any buffered data to be written to the disk.</para>
            </summary>
            <param name="bufmode_type">The buffer mode to use.</param>
            <param name="size">The maximum size in bytes of the file's buffer.</param>
            <returns>Whether the buffer mode was successfully set.</returns>
        </member>
        <member name="M:Love.File.GetBuffer(Love.BufferMode@,System.Int64@)">
            <summary>
            Gets the buffer mode of a file.
            </summary>
            <param name="out_bufmode_type">The current buffer mode of the file.</param>
            <param name="out_size">The maximum size in bytes of the file's buffer.</param>
        </member>
        <member name="M:Love.File.GetMode">
            <summary>
            Gets the <see cref="T:Love.FileMode"/> the file has been opened with.
            </summary>
            <returns>The mode this file has been opened with.</returns>
        </member>
        <member name="M:Love.File.GetFilename">
            <summary>
            Gets the filename that the File object was created with. If the file object originated from the <see cref="M:Love.Scene.FileDropped(Love.File)"/> callback, the filename will be the full platform-dependent file path.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Text.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Text.GetWidth(System.Int32)">
            <summary>
            Gets the width of the text in pixels.
            </summary>
            <param name="index">An index number returned by Text:add or Text:addf.</param>
            <returns>The width of the sub-string (before scaling and other transformations).</returns>
        </member>
        <member name="M:Love.Text.GetHeight(System.Int32)">
            <summary>
            Gets the height of the text in pixels.
            </summary>
            <param name="index">An index number returned by Text:add or Text:addf.</param>
            <returns>The height of the sub-string (before scaling and other transformations).</returns>
        </member>
        <member name="T:Love.Shader">
            <summary>
            A Shader is used for advanced hardware-accelerated pixel or vertex manipulation. These effects are written in a language based on GLSL (OpenGL Shading Language) with a few things simplified for easier coding.
            <para>Potential uses for shaders include HDR/bloom, motion blur, grayscale/invert/sepia/any kind of color effect, reflection/refraction, distortions, bump mapping, and much more! Here is a collection of basic shaders and good starting point to learn: https://github.com/vrld/moonshine </para>
            </summary>
        </member>
        <member name="M:Love.Shader.SendVector2(System.String,Love.Vector2[])">
            <summary>
            Sends one or more Vector2 values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Vector2 to send to the shader.</param>
            <param name="valueArray">Vector2 to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendVector3(System.String,Love.Vector3[])">
            <summary>
            Sends one or more Vector3 values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Vector3 to send to the shader.</param>
            <param name="valueArray">Vector3 to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendVector4(System.String,Love.Vector4[])">
            <summary>
            Sends one or more Vector4 values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Vector4 to send to the shader.</param>
            <param name="valueArray">Vector4 to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,Love.Vector2[])">
            <summary>
            Sends one or more Vector2 values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Vector2 to send to the shader.</param>
            <param name="valueArray">Vector2 to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,Love.Vector3[])">
            <summary>
            Sends one or more Vector3 values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Vector3 to send to the shader.</param>
            <param name="valueArray">Vector3 to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,Love.Vector4[])">
            <summary>
            Sends one or more Vector4 values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Vector4 to send to the shader.</param>
            <param name="valueArray">Vector4 to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,System.Single[])">
            <summary>
            Sends one or more float values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the float to send to the shader.</param>
            <param name="valueArray">Float to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,System.UInt32[])">
            <summary>
            Sends one or more uint values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the uint to send to the shader.</param>
            <param name="valueArray">Uint to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,System.Int32[])">
            <summary>
            Sends one or more int values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the int to send to the shader.</param>
            <param name="valueArray">Int to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,System.Boolean[])">
            <summary>
            Sends one or more boolean values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the boolean to send to the shader.</param>
            <param name="valueArray">Boolean to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,Love.Matrix22[])">
            <summary>
            Sends one or more Matrix22 values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Matrix22 to send to the shader.</param>
            <param name="valueArray">Matrix22 to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,Love.Matrix33[])">
            <summary>
            Sends one or more Matrix33 values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Matrix33 to send to the shader.</param>
            <param name="valueArray">Matrix33 to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,Love.Matrix44[])">
            <summary>
            Sends one or more SendMatrix values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the SendMatrix to send to the shader.</param>
            <param name="valueArray">SendMatrix to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.Send(System.String,Love.Texture)">
            <summary>
            Sends one or more texture to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Texture to send to the shader.(UTF8 byte array)</param>
            <param name="texture">Texture (Image or Canvas) to send to the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.#ctor">
            <summary>
            Use Graphics.NewShader(...) to create Shader !
            </summary>
        </member>
        <member name="M:Love.Shader.GetWarnings">
            <summary>
            Gets warning and error messages (if any).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Shader.SendColors(System.Byte[],Love.Vector4[])">
            <summary>
            Sends one or more colors to a special (extern / uniform) vec3 or vec4 variable inside the shader. The color components must be in the range of [0, 1]. The colors are gamma-corrected if global gamma-correction is enabled.
            </summary>
            <param name="name">The name of the color extern variable to send to in the shader. (UTF8 byte array)</param>
            <param name="valueArray">A array with red, green, blue, and alpha color components in the range of [0, 1] to send to the extern as a vector.</param>
        </member>
        <member name="M:Love.Shader.SendFloats(System.Byte[],System.Single[])">
            <summary>
            Sends one or more float values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the float to send to the shader. (UTF8 byte array)</param>
            <param name="valueArray">Float to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendUints(System.Byte[],System.UInt32[])">
            <summary>
            Sends one or more uint values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the uint to send to the shader. (UTF8 byte array)</param>
            <param name="valueArray">Uint to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendInts(System.Byte[],System.Int32[])">
            <summary>
            Sends one or more int values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the int to send to the shader. (UTF8 byte array)</param>
            <param name="valueArray">Int to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendBooleans(System.Byte[],System.Boolean[])">
            <summary>
            Sends one or more boolean values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the boolean to send to the shader. (UTF8 byte array)</param>
            <param name="valueArray">Boolean to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendMatrix(System.Byte[],System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            WARNNING: incorrect use of this function can carsh program.
            <para> params of valueArray.Length should equals columns * rows * count </para>
            </summary>
            <param name="name">uniform variable name</param>
            <param name="valueArray">each float consistute matrix array</param>
            <param name="columns">matrix columns</param>
            <param name="rows">matrix rows</param>
            <param name="count">matrix count</param>
        </member>
        <member name="M:Love.Shader.SendTexture(System.Byte[],Love.Texture[])">
            <summary>
            Sends one or more texture to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Texture to send to the shader.(UTF8 byte array)</param>
            <param name="texture">Texture (Image or Canvas) to send to the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendColors(System.String,Love.Vector4[])">
            <summary>
            Sends one or more colors to a special (extern / uniform) vec3 or vec4 variable inside the shader. The color components must be in the range of [0, 1]. The colors are gamma-corrected if global gamma-correction is enabled.
            </summary>
            <param name="name">The name of the color extern variable to send to in the shader.</param>
            <param name="valueArray">A array with red, green, blue, and alpha color components in the range of [0, 1] to send to the extern as a vector.</param>
        </member>
        <member name="M:Love.Shader.SendFloats(System.String,System.Single[])">
            <summary>
            Sends one or more float values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the float to send to the shader.</param>
            <param name="valueArray">Float to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendUints(System.String,System.UInt32[])">
            <summary>
            Sends one or more uint values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the uint to send to the shader.</param>
            <param name="valueArray">Uint to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendInts(System.String,System.Int32[])">
            <summary>
            Sends one or more int values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the int to send to the shader.</param>
            <param name="valueArray">Int to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendBooleans(System.String,System.Boolean[])">
            <summary>
            Sends one or more boolean values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the boolean to send to the shader.</param>
            <param name="valueArray">Boolean to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendMatrix(System.String,System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            WARNNING: incorrect use of this function can carsh program.
            <para> params of valueArray.Length should equals columns * rows * count </para>
            </summary>
            <param name="name">uniform variable name</param>
            <param name="valueArray">each float consistute matrix array</param>
            <param name="columns">matrix columns</param>
            <param name="rows">matrix rows</param>
            <param name="count">matrix count</param>
        </member>
        <member name="M:Love.Shader.SendMatrix(System.String,Love.Matrix22[])">
            <summary>
            Sends one or more Matrix22 values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Matrix22 to send to the shader.</param>
            <param name="valueArray">Matrix22 to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendMatrix(System.String,Love.Matrix33[])">
            <summary>
            Sends one or more Matrix33 values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Matrix33 to send to the shader.</param>
            <param name="valueArray">Matrix33 to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendMatrix(System.String,Love.Matrix44[])">
            <summary>
            Sends one or more SendMatrix values to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the SendMatrix to send to the shader.</param>
            <param name="valueArray">SendMatrix to send to store in the uniform variable.</param>
        </member>
        <member name="M:Love.Shader.SendTexture(System.String,Love.Texture)">
            <summary>
            Sends one or more texture to a special (uniform) variable inside the shader.
            </summary>
            <param name="name">Name of the Texture to send to the shader.(UTF8 byte array)</param>
            <param name="texture">Texture (Image or Canvas) to send to the uniform variable.</param>
        </member>
        <member name="T:Love.Point">
            <summary>
               Represents an ordered pair of x and y coordinates that
               define a point in a two-dimensional plane.
            </summary>
        </member>
        <member name="F:Love.Point.Empty">
            <summary>
               Creates a new instance of the <see cref='T:Love.Point'/> class
               with member data left uninitialized.
            </summary>
        </member>
        <member name="M:Love.Point.#ctor(System.Int32,System.Int32)">
            <summary>
               Initializes a new instance of the <see cref='T:Love.Point'/> class
               with the specified coordinates.
            </summary>
        </member>
        <member name="M:Love.Point.#ctor(Love.Size)">
            <summary>
               <para>
                  Initializes a new instance of the <see cref='T:Love.Point'/> class
                  from a <see cref='!:System.Drawing.Size'/> .
               </para>
            </summary>
        </member>
        <member name="M:Love.Point.#ctor(System.Int32)">
            <summary>
               Initializes a new instance of the Point class using
               coordinates specified by an integer value.
            </summary>
        </member>
        <member name="P:Love.Point.IsEmpty">
            <summary>
               <para>
                  Gets a value indicating whether this <see cref='T:Love.Point'/> is empty.
               </para>
            </summary>
        </member>
        <member name="P:Love.Point.X">
            <summary>
               Gets the x-coordinate of this <see cref='T:Love.Point'/>.
            </summary>
        </member>
        <member name="P:Love.Point.Y">
            <summary>
               <para>
                  Gets the y-coordinate of this <see cref='T:Love.Point'/>.
               </para>
            </summary>
        </member>
        <member name="M:Love.Point.op_Implicit(Love.Point)~Love.Vector2">
            <summary>
               <para>
                  Creates a <see cref='T:Love.Vector2'/> with the coordinates of the specified
               <see cref='T:Love.Point'/> 
            </para>
            </summary>
        </member>
        <member name="M:Love.Point.op_Explicit(Love.Point)~Love.Size">
            <summary>
               <para>
                  Creates a <see cref='!:System.Drawing.Size'/> with the coordinates of the specified <see cref='T:Love.Point'/> .
               </para>
            </summary>
        </member>
        <member name="M:Love.Point.op_Addition(Love.Point,Love.Size)">
            <summary>
               <para>
                  Translates a <see cref='T:Love.Point'/> by a given <see cref='!:System.Drawing.Size'/> .
               </para>
            </summary>        
        </member>
        <member name="M:Love.Point.op_Subtraction(Love.Point,Love.Size)">
            <summary>
               <para>
                  Translates a <see cref='T:Love.Point'/> by the negative of a given <see cref='!:System.Drawing.Size'/> .
               </para>
            </summary>        
        </member>
        <member name="M:Love.Point.op_Equality(Love.Point,Love.Point)">
            <summary>
               <para>
                  Compares two <see cref='T:Love.Point'/> objects. The result specifies
                  whether the values of the <see cref='P:Love.Point.X'/> and <see cref='P:Love.Point.Y'/> properties of the two <see cref='T:Love.Point'/>
                  objects are equal.
               </para>
            </summary>
        </member>
        <member name="M:Love.Point.op_Inequality(Love.Point,Love.Point)">
            <summary>
               <para>
                  Compares two <see cref='T:Love.Point'/> objects. The result specifies whether the values
                  of the <see cref='P:Love.Point.X'/> or <see cref='P:Love.Point.Y'/> properties of the two
               <see cref='T:Love.Point'/> 
               objects are unequal.
            </para>
            </summary>
        </member>
        <member name="M:Love.Point.Add(Love.Point,Love.Size)">
            <summary>
               <para>
                  Translates a <see cref='T:Love.Point'/> by a given <see cref='!:System.Drawing.Size'/> .
               </para>
            </summary>        
        </member>
        <member name="M:Love.Point.Subtract(Love.Point,Love.Size)">
            <summary>
               <para>
                  Translates a <see cref='T:Love.Point'/> by the negative of a given <see cref='!:System.Drawing.Size'/> .
               </para>
            </summary>        
        </member>
        <member name="M:Love.Point.Ceiling(Love.Vector2)">
            <summary>
              Converts a PointF to a Point by performing a ceiling operation on
              all the coordinates.
            </summary>
        </member>
        <member name="M:Love.Point.Truncate(Love.Vector2)">
            <summary>
              Converts a PointF to a Point by performing a truncate operation on
              all the coordinates.
            </summary>
        </member>
        <member name="M:Love.Point.Round(Love.Vector2)">
            <summary>
              Converts a PointF to a Point by performing a round operation on
              all the coordinates.
            </summary>
        </member>
        <member name="M:Love.Point.Equals(System.Object)">
            <summary>
               <para>
                  Specifies whether this <see cref='T:Love.Point'/> contains
                  the same coordinates as the specified <see cref='T:System.Object'/>.
               </para>
            </summary>
        </member>
        <member name="M:Love.Point.GetHashCode">
            <summary>
               <para>
                  Returns a hash code.
               </para>
            </summary>
        </member>
        <member name="M:Love.Point.Offset(System.Int32,System.Int32)">
            <summary>
               Translates this <see cref='T:Love.Point'/> by the specified amount.
            </summary>
        </member>
        <member name="M:Love.Point.Offset(Love.Point)">
            <summary>
               Translates this <see cref='T:Love.Point'/> by the specified amount.
            </summary>
        </member>
        <member name="M:Love.Point.ToString">
            <summary>
               <para>
                  Converts this <see cref='T:Love.Point'/>
                  to a human readable
                  string.
               </para>
            </summary>
        </member>
        <member name="M:Love.Ray2D.Intersects(Love.Ray2D,Love.RectangleF,Love.Vector2@)">
            <summary>
            Raycast for intersection of rectangle and ray, if any return true.
            <para> modify form this file : https://github.com/erich666/GraphicsGems/blob/master/gems/RayBox.c </para>
            <para> https://gamedev.stackexchange.com/questions/18436/most-efficient-aabb-vs-ray-collision-algorithms </para>
            <para> https://tavianator.com/fast-branchless-raybounding-box-intersections/ </para>
            </summary>
            <param name="rect">the input rect</param>
            <param name="ray">the ray to raycast</param>
            <param name="result">Intersection of rectangle and ray</param>
            <returns></returns>
        </member>
        <member name="M:Love.Ray2D.Intersects(Love.RectangleF,Love.Vector2@)">
            <summary>
            Raycast for intersection of rectangle and ray, if any return true.
            </summary>
            <param name="rect">the rectangle to test</param>
            <param name="result">the intersection(if any)</param>
            <returns></returns>
        </member>
        <member name="T:Love.Rectangle">
            <summary>
               <para>
                  Stores the location and size of a rectangular region. 
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
               <para>
                  Initializes a new instance of the <see cref='T:Love.Rectangle'/>
                  class with the specified location and size.
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.#ctor(Love.Point,Love.Size)">
            <summary>
               <para>
                  Initializes a new instance of the Rectangle class with the specified location
                  and size.
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.FromLTRB(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
               Creates a new <see cref='T:Love.Rectangle'/> with
               the specified location and size.
            </summary>
        </member>
        <member name="P:Love.Rectangle.Location">
            <summary>
               <para>
                  Gets or sets the coordinates of the
                  upper-left corner of the rectangular region represented by this <see cref='T:Love.Rectangle'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.Rectangle.Size">
            <summary>
               Gets or sets the size of this <see cref='T:Love.Rectangle'/>.
            </summary>
        </member>
        <member name="P:Love.Rectangle.X">
            <summary>
               Gets or sets the x-coordinate of the
               upper-left corner of the rectangular region defined by this <see cref='T:Love.Rectangle'/>.
            </summary>
        </member>
        <member name="P:Love.Rectangle.Y">
            <summary>
               Gets or sets the y-coordinate of the
               upper-left corner of the rectangular region defined by this <see cref='T:Love.Rectangle'/>.
            </summary>
        </member>
        <member name="P:Love.Rectangle.Width">
            <summary>
               Gets or sets the width of the rectangular
               region defined by this <see cref='T:Love.Rectangle'/>.
            </summary>
        </member>
        <member name="P:Love.Rectangle.Height">
            <summary>
               Gets or sets the width of the rectangular
               region defined by this <see cref='T:Love.Rectangle'/>.
            </summary>
        </member>
        <member name="P:Love.Rectangle.Left">
            <summary>
               <para>
                  Gets the x-coordinate of the upper-left corner of the
                  rectangular region defined by this <see cref='T:Love.Rectangle'/> .
               </para>
            </summary>
        </member>
        <member name="P:Love.Rectangle.Top">
            <summary>
               <para>
                  Gets the y-coordinate of the upper-left corner of the
                  rectangular region defined by this <see cref='T:Love.Rectangle'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.Rectangle.Right">
            <summary>
               <para>
                  Gets the x-coordinate of the lower-right corner of the
                  rectangular region defined by this <see cref='T:Love.Rectangle'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.Rectangle.Bottom">
            <summary>
               <para>
                  Gets the y-coordinate of the lower-right corner of the
                  rectangular region defined by this <see cref='T:Love.Rectangle'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.Rectangle.IsEmpty">
            <summary>
               <para>
                  Tests whether this <see cref='T:Love.Rectangle'/> has a <see cref='P:Love.Rectangle.Width'/>
                  or a <see cref='P:Love.Rectangle.Height'/> of 0.
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.Equals(System.Object)">
            <summary>
               <para>
                  Tests whether <paramref name="obj"/> is a <see cref='T:Love.Rectangle'/> with
                  the same location and size of this Rectangle.
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.op_Equality(Love.Rectangle,Love.Rectangle)">
            <summary>
               <para>
                  Tests whether two <see cref='T:Love.Rectangle'/>
                  objects have equal location and size.
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.op_Inequality(Love.Rectangle,Love.Rectangle)">
            <summary>
               <para>
                  Tests whether two <see cref='T:Love.Rectangle'/>
                  objects differ in location or size.
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.Ceiling(Love.RectangleF)">
            <summary>
              Converts a RectangleF to a Rectangle by performing a ceiling operation on
              all the coordinates.
            </summary>
        </member>
        <member name="M:Love.Rectangle.Truncate(Love.RectangleF)">
            <summary>
              Converts a RectangleF to a Rectangle by performing a truncate operation on
              all the coordinates.
            </summary>
        </member>
        <member name="M:Love.Rectangle.Round(Love.RectangleF)">
            <summary>
              Converts a RectangleF to a Rectangle by performing a round operation on
              all the coordinates.
            </summary>
        </member>
        <member name="M:Love.Rectangle.Contains(System.Int32,System.Int32)">
            <summary>
               <para>
                  Determines if the specified point is contained within the
                  rectangular region defined by this <see cref='T:Love.Rectangle'/> .
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.Contains(Love.Point)">
            <summary>
               <para>
                  Determines if the specified point is contained within the
                  rectangular region defined by this <see cref='T:Love.Rectangle'/> .
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.Contains(Love.Rectangle)">
            <summary>
               <para>
                  Determines if the rectangular region represented by
               <paramref name="rect"/> is entirely contained within the rectangular region represented by 
                  this <see cref='T:Love.Rectangle'/> .
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.Inflate(System.Int32,System.Int32)">
            <summary>
               <para>
                  Inflates this <see cref='T:Love.Rectangle'/>
                  by the specified amount.
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.Inflate(Love.Size)">
            <summary>
               Inflates this <see cref='T:Love.Rectangle'/> by the specified amount.
            </summary>
        </member>
        <member name="M:Love.Rectangle.Inflate(Love.Rectangle,System.Int32,System.Int32)">
            <summary>
               <para>
                  Creates a <see cref='T:Love.Rectangle'/>
                  that is inflated by the specified amount.
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.Intersect(Love.Rectangle)">
            <summary> Creates a Rectangle that represents the intersection between this Rectangle and rect.
            </summary>
        </member>
        <member name="M:Love.Rectangle.Intersect(Love.Rectangle,Love.Rectangle)">
            <summary>
               Creates a rectangle that represents the intersection between a and
               b. If there is no intersection, null is returned.
            </summary>
        </member>
        <member name="M:Love.Rectangle.IntersectsWith(Love.Rectangle)">
            <summary>
                Determines if this rectangle intersects with rect.
            </summary>
        </member>
        <member name="M:Love.Rectangle.Union(Love.Rectangle,Love.Rectangle)">
            <summary>
               <para>
                  Creates a rectangle that represents the union between a and
                  b.
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.Offset(Love.Point)">
            <summary>
               <para>
                  Adjusts the location of this rectangle by the specified amount.
               </para>
            </summary>
        </member>
        <member name="M:Love.Rectangle.Offset(System.Int32,System.Int32)">
            <summary>
               Adjusts the location of this rectangle by the specified amount.
            </summary>
        </member>
        <member name="M:Love.Rectangle.ToString">
            <summary>
               <para>
                  Converts the attributes of this <see cref='T:Love.Rectangle'/> to a
                  human readable string.
               </para>
            </summary>
        </member>
        <member name="T:Love.RectangleF">
            <summary>
               <para>
                  Stores the location and size of a rectangular region.
               </para>
            </summary>
        </member>
        <member name="F:Love.RectangleF.Empty">
            <summary>
               Initializes a new instance of the <see cref='T:Love.RectangleF'/>
               class.
            </summary>
        </member>
        <member name="M:Love.RectangleF.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
               <para>
                  Initializes a new instance of the <see cref='T:Love.RectangleF'/>
                  class with the specified location and size.
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.#ctor(Love.Vector2,Love.SizeF)">
            <summary>
               <para>
                  Initializes a new instance of the <see cref='T:Love.RectangleF'/>
                  class with the specified location
                  and size.
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.FromLTRB(System.Single,System.Single,System.Single,System.Single)">
            <summary>
               <para>
                  Creates a new <see cref='T:Love.RectangleF'/> with
                  the specified location and size.
               </para>
            </summary>
        </member>
        <member name="P:Love.RectangleF.Location">
            <summary>
               <para>
                  Gets or sets the coordinates of the upper-left corner of
                  the rectangular region represented by this <see cref='T:Love.RectangleF'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.RectangleF.Size">
            <summary>
               <para>
                  Gets or sets the size of this <see cref='T:Love.RectangleF'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.RectangleF.X">
            <summary>
               <para>
                  Gets or sets the x-coordinate of the
                  upper-left corner of the rectangular region defined by this <see cref='T:Love.RectangleF'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.RectangleF.Y">
            <summary>
               <para>
                  Gets or sets the y-coordinate of the
                  upper-left corner of the rectangular region defined by this <see cref='T:Love.RectangleF'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.RectangleF.Width">
            <summary>
               <para>
                  Gets or sets the width of the rectangular
                  region defined by this <see cref='T:Love.RectangleF'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.RectangleF.Height">
            <summary>
               <para>
                  Gets or sets the height of the
                  rectangular region defined by this <see cref='T:Love.RectangleF'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.RectangleF.Left">
            <summary>
               <para>
                  Gets the x-coordinate of the upper-left corner of the
                  rectangular region defined by this <see cref='T:Love.RectangleF'/> .
               </para>
            </summary>
        </member>
        <member name="P:Love.RectangleF.Top">
            <summary>
               <para>
                  Gets the y-coordinate of the upper-left corner of the
                  rectangular region defined by this <see cref='T:Love.RectangleF'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.RectangleF.Right">
            <summary>
               <para>
                  Gets the x-coordinate of the lower-right corner of the
                  rectangular region defined by this <see cref='T:Love.RectangleF'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.RectangleF.Bottom">
            <summary>
               <para>
                  Gets the y-coordinate of the lower-right corner of the
                  rectangular region defined by this <see cref='T:Love.RectangleF'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.RectangleF.IsEmpty">
            <summary>
               <para>
                  Tests whether this <see cref='T:Love.RectangleF'/> has a <see cref='P:Love.RectangleF.Width'/> or a <see cref='P:Love.RectangleF.Height'/> of 0.
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.Equals(System.Object)">
            <summary>
               <para>
                  Tests whether <paramref name="obj"/> is a <see cref='T:Love.RectangleF'/> with the same location and size of this
               <see cref='T:Love.RectangleF'/>.
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.op_Equality(Love.RectangleF,Love.RectangleF)">
            <summary>
               <para>
                  Tests whether two <see cref='T:Love.RectangleF'/>
                  objects have equal location and size.
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.op_Inequality(Love.RectangleF,Love.RectangleF)">
            <summary>
               <para>
                  Tests whether two <see cref='T:Love.RectangleF'/>
                  objects differ in location or size.
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.Contains(System.Single,System.Single)">
            <summary>
               <para>
                  Determines if the specified point is contained within the
                  rectangular region defined by this <see cref='T:Love.Rectangle'/> .
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.Contains(Love.Vector2)">
            <summary>
               <para>
                  Determines if the specified point is contained within the
                  rectangular region defined by this <see cref='T:Love.Rectangle'/> .
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.Contains(Love.RectangleF)">
            <summary>
               <para>
                  Determines if the rectangular region represented by
               <paramref name="rect"/> is entirely contained within the rectangular region represented by 
                  this <see cref='T:Love.Rectangle'/> .
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.GetHashCode">
            <summary>
               Gets the hash code for this <see cref='T:Love.RectangleF'/>.
            </summary>
        </member>
        <member name="M:Love.RectangleF.Inflate(System.Single,System.Single)">
            <summary>
               <para>
                  Inflates this <see cref='T:Love.Rectangle'/>
                  by the specified amount.
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.Inflate(Love.SizeF)">
            <summary>
               Inflates this <see cref='T:Love.Rectangle'/> by the specified amount.
            </summary>
        </member>
        <member name="M:Love.RectangleF.Inflate(Love.RectangleF,System.Single,System.Single)">
            <summary>
               <para>
                  Creates a <see cref='T:Love.Rectangle'/>
                  that is inflated by the specified amount.
               </para>
            </summary>
        </member>
        <member name="M:Love.RectangleF.Intersect(Love.RectangleF)">
            <summary> Creates a Rectangle that represents the intersection between this Rectangle and rect.
            </summary>
        </member>
        <member name="M:Love.RectangleF.Intersect(Love.RectangleF,Love.RectangleF)">
            <summary>
               Creates a rectangle that represents the intersection between a and
               b. If there is no intersection, null is returned.
            </summary>
        </member>
        <member name="M:Love.RectangleF.IntersectsWith(Love.RectangleF)">
            <summary>
               Determines if this rectangle intersects with rect.
            </summary>
        </member>
        <member name="M:Love.RectangleF.Union(Love.RectangleF,Love.RectangleF)">
            <summary>
               Creates a rectangle that represents the union between a and
               b.
            </summary>
        </member>
        <member name="M:Love.RectangleF.Offset(Love.Vector2)">
            <summary>
               Adjusts the location of this rectangle by the specified amount.
            </summary>
        </member>
        <member name="M:Love.RectangleF.Offset(System.Single,System.Single)">
            <summary>
               Adjusts the location of this rectangle by the specified amount.
            </summary>
        </member>
        <member name="M:Love.RectangleF.op_Implicit(Love.Rectangle)~Love.RectangleF">
            <summary>
               Converts the specified <see cref='T:Love.Rectangle'/> to a
            <see cref='T:Love.RectangleF'/>.
            </summary>
        </member>
        <member name="M:Love.RectangleF.ToString">
            <summary>
               Converts the <see cref='P:Love.RectangleF.Location'/> and <see cref='P:Love.RectangleF.Size'/> of this <see cref='T:Love.RectangleF'/> to a
               human-readable string.
            </summary>
        </member>
        <member name="T:Love.Resource">
            <summary>
            This module will create resource through starndard C# IO, 
            this means you can read a png file from path like C:/love-logo.png
            </summary>
        </member>
        <member name="M:Love.Resource.NewSource(System.String,Love.SourceType)">
            <summary>
            Creates a new Source from file name. 
            </summary>
            <param name="filename">The filepath to the audio file.</param>
            <param name="type">Streaming or static source.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Resource.NewFileData(System.String)">
            <summary>
            Creates a new FileData object. This function will read file from standard C# IO File system.
            </summary>
            <param name="fileName">file name, such as C:/love-logo.png </param>
            <returns></returns>
        </member>
        <member name="M:Love.Resource.Append(System.String,System.Byte[])">
            <summary>
            Append data to an existing file. 
            </summary>
            <param name="path">The name (and path) of the file.</param>
            <param name="byteArray">The data to append to the file.</param>
        </member>
        <member name="M:Love.Resource.Append(System.String,System.String)">
            <summary>
            Append data to an existing file. 
            </summary>
            <param name="path">The name (and path) of the file.</param>
            <param name="content">The string to append to the file.</param>
        </member>
        <member name="M:Love.Resource.Append(System.String,System.String,System.Text.Encoding)">
            <summary>
            Append data to an existing file. 
            </summary>
            <param name="path">The name (and path) of the file.</param>
            <param name="content">The string to append to the file.</param>
            <param name="encoding">string encoding.</param>
        </member>
        <member name="M:Love.Resource.CreateDirectory(System.String)">
            <summary>
            <para>Recursively creates a directory.</para>
            <para>When called with "a/b" it creates both "a" and "a/b", if they don't exist already.</para>
            </summary>
            <param name="pathString">The directory to create.</param>
            <returns>True if the directory was created, false if not.</returns>
        </member>
        <member name="M:Love.Resource.GetDirectoryItems(System.String)">
            <summary>
            <para>Returns a table with the names of files and subdirectories in the specified path. The array is not sorted in any way; the order is undefined.</para>
            <para>If the path passed to the function exists in the game and the save directory, it will list the files and directories from both places.</para>
            </summary>
            <param name="path">The directory.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Resource.GetInfo(System.String)">
            <summary>
            Gets information about the specified file or directory.
            </summary>
            <param name="path">The file or directory path to check.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Resource.Lines(System.Action{System.String},System.String)">
            <summary>
            Iterate over the lines in a file.
            </summary>
            <param name="lineFunction"></param>
            <param name="path"></param>
        </member>
        <member name="M:Love.Resource.Read(System.String)">
            <summary>
            Read the all contents of a file.
            </summary>
            <param name="filename">The name (and path) of the file.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Resource.Read(System.String,System.Int32)">
            <summary>
            Read the all contents of a file.
            </summary>
            <param name="filename">The name (and path) of the file.</param>
            <param name="len">How many bytes to read.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Resource.Remove(System.String)">
            <summary>
            Removes a file (or directory).
            </summary>
            <param name="path">The file or directory to remove.</param>
        </member>
        <member name="M:Love.Resource.Write(System.String,System.Byte[])">
            <summary>
            Write data to a file in the save directory. If the file existed already, it will be completely replaced by the new contents.
            </summary>
            <param name="path">The name (and path) of the file.</param>
            <param name="bytes">The data to write to the file.</param>
        </member>
        <member name="M:Love.Resource.Write(System.String,System.String)">
            <summary>
            Write data to a file in the save directory. If the file existed already, it will be completely replaced by the new contents.
            </summary>
            <param name="filename">The name (and path) of the file.</param>
            <param name="contents">The string data to write to the file.</param>
        </member>
        <member name="M:Love.Resource.Write(System.String,System.String,System.Text.Encoding)">
            <summary>
            Write data to a file in the save directory. If the file existed already, it will be completely replaced by the new contents.
            </summary>
            <param name="filename">The name (and path) of the file.</param>
            <param name="contents">The string data to write to the file.</param>
            <param name="encoding">string encodeing</param>
        </member>
        <member name="M:Love.Resource.NewRasterizer(System.String)">
            <summary>
            Creates a new Rasterizer.
            </summary>
            <param name="filename">The font file.</param>
            <returns>The rasterizer.</returns>
        </member>
        <member name="M:Love.Resource.NewFont(System.String,System.Int32,Love.HintingMode)">
            <summary>
            Create a new TrueType font.
            </summary>
            <param name="filename">The filepath to the TrueType font file.</param>
            <param name="size">The size of the font in pixels.</param>
            <param name="hinting">True Type hinting mode.</param>
            <returns>A Font object which can be used to draw text on screen.</returns>
        </member>
        <member name="M:Love.Resource.NewBMFont(System.String,System.String[])">
            <summary>
            </summary>
            <param name="filename">The filepath to the BMFont file.</param>
            <param name="imageFileName">The filepath to the BMFont's image file.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Resource.NewImage(System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Image from a filepath.
            </summary>
            <param name="filename">The filepath to the image file .</param>
            <param name="flagMipmaps">If true, mipmaps for the image will be automatically generated (or taken from the images's file if possible, if the image originated from a CompressedImageData). If this value is a table, it should contain a list of other filenames of images of the same format that have progressively half-sized dimensions, all the way down to 1x1. Those images will be used as this Image's mipmap levels.</param>
            <param name="flagLinear">True if the image's pixels should be interpreted as being linear RGB rather than sRGB-encoded, if gamma-correct rendering is enabled. Has no effect otherwise.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Resource.NewImageFont(System.String,System.String,System.Int32)">
            <summary>
            Creates a new Font by loading a specifically formatted image.
            <para>In versions prior to 0.9.0, LÖVE expects ISO 8859-1 encoding for the glyphs string.</para>
            <para>	This function can be slow if it is called repeatedly, such as from Scene.Update. If you need to use a specific resource often, create it once and store it somewhere it can be reused!</para>
            </summary>
            <param name="filename">The filepath to the image file.</param>
            <param name="glyphs">A string of the characters in the image in order from left to right.</param>
            <param name="extraspacing">Additional spacing (positive or negative) to apply to each glyph in the Font.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Resource.NewImageData(System.String)">
            <summary>
            Creates a new <see cref="T:Love.ImageData"/> object.
            </summary>
            <param name="filename">The filename of the image file.</param>
            <returns>The new ImageData object.</returns>
        </member>
        <member name="M:Love.Resource.NewCompressedData(System.String)">
            <summary>
            Create a new <see cref="T:Love.CompressedImageData"/> object from a compressed image file. LÖVE supports several compressed texture formats, enumerated in the <see cref="T:Love.PixelFormat"/> page.
            </summary>
            <param name="filename">The filename of the compressed image file.</param>
            <returns>The new CompressedImageData object.</returns>
        </member>
        <member name="M:Love.Resource.EncodeToFile(System.String,Love.ImageData,Love.ImageFormat)">
             <summary>
             Encodes the ImageData and writes it to the path.
             </summary>
             <param name="path">The filename to write the file to.</param>
             <param name="imageData">The imageData to write the file to. </param>
             <param name="format">The format to encode the image as.</param>
             <returns></returns>
             <example>
             Draw red rectangle to canvas, and presss F12 to save png file at 'D:/a.png'
             <code>
             class TestSavePngNew : Scene
             {
                 Canvas canvas = null;
            
                 public override void Load()
                 {
                     canvas = Graphics.NewCanvas();
                 }
            
                 public override void KeyPressed(KeyConstant key, Scancode scancode, bool isRepeat)
                 {
                     if (key == KeyConstant.F12)
                     {
                         Resource.EncodeToFile("D:/a.png", canvas.NewImageData(), ImageFormat.PNG);
                     }
                 }
            
                 public override void Draw()
                 {
                     Graphics.SetCanvas(canvas);
                     Graphics.SetColor(Color.Red);
                     Graphics.Rectangle(DrawMode.Fill, 100, 200, 300, 400);
                     Graphics.SetCanvas();
            
                     Graphics.Draw(canvas);
                 }
             }
             </code>
             </example>
        </member>
        <member name="M:Love.Resource.NewCursor(System.String,System.Int32,System.Int32)">
            <summary>
            <para>Creates a new hardware Cursor object from an image file or ImageData.</para>
            <para>Hardware cursors are framerate-independent and work the same way as normal operating system cursors. Unlike drawing an image at the mouse's current coordinates, hardware cursors never have visible lag between when the mouse is moved and when the cursor position updates, even at low framerates.</para>
            <para>The hot spot is the point the operating system uses to determine what was clicked and at what position the mouse cursor is. For example, the normal arrow pointer normally has its hot spot at the top left of the image, but a crosshair cursor might have it in the middle.</para>
            </summary>
            <param name="filename">Path to the image to use for the new Cursor.</param>
            <param name="hotX">The x-coordinate in the image of the cursor's hot spot.</param>
            <param name="hotY">The y-coordinate in the image of the cursor's hot spot.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Resource.NewDecoder(System.String,System.Int32)">
            <summary>
            Attempts to find a decoder for the encoded sound data in the specified file.
            </summary>
            <param name="filename">The filename of the file with encoded sound data.</param>
            <param name="bufferSize">The size of each decoded chunk, in bytes.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Resource.NewSoundData(System.String)">
            <summary>
            <para> Creates a new SoundData.</para>
            <para>It's also possible to create SoundData with a custom sample rate, channel and bit depth.</para>
            <para>The sound data will be decoded to the memory in a raw format. It is recommended to create only short sounds like effects, as a 3 minute song uses 30 MB of memory this way.</para>
            </summary>
            <param name="filename">The file name of the file to load.</param>
            <returns>A new SoundData object.</returns>
        </member>
        <member name="T:Love.Size">
            Represents a dimension in 2D coordinate space
            <summary>
               Represents the size of a rectangular region
               with an ordered pair of width and height.
            </summary>
        </member>
        <member name="F:Love.Size.Empty">
            <summary>
               Initializes a new instance of the <see cref='T:Love.Size'/> class.
            </summary>
        </member>
        <member name="M:Love.Size.#ctor(Love.Point)">
            Create a new Size object from a point
            <summary>
               <para>
                  Initializes a new instance of the <see cref='T:Love.Size'/> class from
                  the specified <see cref='!:System.Drawing.Point'/>.
               </para>
            </summary>
        </member>
        <member name="M:Love.Size.#ctor(System.Int32,System.Int32)">
            Create a new Size object of the specified dimension
            <summary>
               Initializes a new instance of the <see cref='T:Love.Size'/> class from
               the specified dimensions.
            </summary>
        </member>
        <member name="M:Love.Size.op_Implicit(Love.Size)~Love.SizeF">
            <summary>
               Converts the specified <see cref='T:Love.Size'/> to a
            <see cref='T:Love.SizeF'/>.
            </summary>
        </member>
        <member name="M:Love.Size.op_Addition(Love.Size,Love.Size)">
            <summary>
               <para>
                  Performs vector addition of two <see cref='T:Love.Size'/> objects.
               </para>
            </summary>
        </member>
        <member name="M:Love.Size.op_Subtraction(Love.Size,Love.Size)">
            <summary>
               <para>
                  Contracts a <see cref='T:Love.Size'/> by another <see cref='T:Love.Size'/>
               </para>
            </summary>
        </member>
        <member name="M:Love.Size.op_Multiply(System.Int32,Love.Size)">
            <summary>
            Multiplies a <see cref="T:Love.Size"/> by an <see cref="T:System.Int32"/> producing <see cref="T:Love.Size"/>.
            </summary>
            <param name="left">Multiplier of type <see cref="T:System.Int32"/>.</param>
            <param name="right">Multiplicand of type <see cref="T:Love.Size"/>.</param>
            <returns>Product of type <see cref="T:Love.Size"/>.</returns>
        </member>
        <member name="M:Love.Size.op_Multiply(Love.Size,System.Int32)">
            <summary>
            Multiplies <see cref="T:Love.Size"/> by an <see cref="T:System.Int32"/> producing <see cref="T:Love.Size"/>.
            </summary>
            <param name="left">Multiplicand of type <see cref="T:Love.Size"/>.</param>
            <param name="right">Multiplier of type <see cref="T:System.Int32"/>.</param>
            <returns>Product of type <see cref="T:Love.Size"/>.</returns>
        </member>
        <member name="M:Love.Size.op_Division(Love.Size,System.Int32)">
            <summary>
            Divides <see cref="T:Love.Size"/> by an <see cref="T:System.Int32"/> producing <see cref="T:Love.Size"/>.
            </summary>
            <param name="left">Dividend of type <see cref="T:Love.Size"/>.</param>
            <param name="right">Divisor of type <see cref="T:System.Int32"/>.</param>
            <returns>Result of type <see cref="T:Love.Size"/>.</returns>
        </member>
        <member name="M:Love.Size.op_Multiply(System.Single,Love.Size)">
            <summary>
            Multiplies <see cref="T:Love.Size"/> by a <see cref="T:System.Single"/> producing <see cref="T:Love.SizeF"/>.
            </summary>
            <param name="left">Multiplier of type <see cref="T:System.Single"/>.</param>
            <param name="right">Multiplicand of type <see cref="T:Love.Size"/>.</param>
            <returns>Product of type <see cref="T:Love.SizeF"/>.</returns>
        </member>
        <member name="M:Love.Size.op_Multiply(Love.Size,System.Single)">
            <summary>
            Multiplies <see cref="T:Love.Size"/> by a <see cref="T:System.Single"/> producing <see cref="T:Love.SizeF"/>.
            </summary>
            <param name="left">Multiplicand of type <see cref="T:Love.Size"/>.</param>
            <param name="right">Multiplier of type <see cref="T:System.Single"/>.</param>
            <returns>Product of type <see cref="T:Love.SizeF"/>.</returns>
        </member>
        <member name="M:Love.Size.op_Division(Love.Size,System.Single)">
            <summary>
            Divides <see cref="T:Love.Size"/> by a <see cref="T:System.Single"/> producing <see cref="T:Love.SizeF"/>.
            </summary>
            <param name="left">Dividend of type <see cref="T:Love.Size"/>.</param>
            <param name="right">Divisor of type <see cref="T:System.Int32"/>.</param>
            <returns>Result of type <see cref="T:Love.SizeF"/>.</returns>
        </member>
        <member name="M:Love.Size.op_Equality(Love.Size,Love.Size)">
            <summary>
               Tests whether two <see cref='T:Love.Size'/> objects
               are identical.
            </summary>
        </member>
        <member name="M:Love.Size.op_Inequality(Love.Size,Love.Size)">
            <summary>
               <para>
                  Tests whether two <see cref='T:Love.Size'/> objects are different.
               </para>
            </summary>
        </member>
        <member name="M:Love.Size.op_Explicit(Love.Size)~Love.Point">
            <summary>
               Converts the specified <see cref='T:Love.Size'/> to a
            <see cref='!:System.Drawing.Point'/>.
            </summary>
        </member>
        <member name="P:Love.Size.IsEmpty">
            <summary>
               Tests whether this <see cref='T:Love.Size'/> has zero
               width and height.
            </summary>
        </member>
        <member name="P:Love.Size.Width">
            Horizontal dimension
            <summary>
               <para>
                  Represents the horizontal component of this
               <see cref='T:Love.Size'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.Size.Height">
            Vertical dimension
            <summary>
               Represents the vertical component of this
            <see cref='T:Love.Size'/>.
            </summary>
        </member>
        <member name="M:Love.Size.Add(Love.Size,Love.Size)">
            <summary>
               <para>
                  Performs vector addition of two <see cref='T:Love.Size'/> objects.
               </para>
            </summary>
        </member>
        <member name="M:Love.Size.Ceiling(Love.SizeF)">
            <summary>
              Converts a SizeF to a Size by performing a ceiling operation on
              all the coordinates.
            </summary>
        </member>
        <member name="M:Love.Size.Subtract(Love.Size,Love.Size)">
            <summary>
               <para>
                  Contracts a <see cref='T:Love.Size'/> by another <see cref='T:Love.Size'/> .
               </para>
            </summary>
        </member>
        <member name="M:Love.Size.Truncate(Love.SizeF)">
            <summary>
              Converts a SizeF to a Size by performing a truncate operation on
              all the coordinates.
            </summary>
        </member>
        <member name="M:Love.Size.Round(Love.SizeF)">
            <summary>
              Converts a SizeF to a Size by performing a round operation on
              all the coordinates.
            </summary>
        </member>
        <member name="M:Love.Size.Equals(System.Object)">
            <summary>
               <para>
                  Tests to see whether the specified object is a
               <see cref='T:Love.Size'/> 
               with the same dimensions as this <see cref='T:Love.Size'/>.
            </para>
            </summary>
        </member>
        <member name="M:Love.Size.GetHashCode">
            <summary>
               <para>
                  Returns a hash code.
               </para>
            </summary>
        </member>
        <member name="M:Love.Size.ToString">
            <summary>
               <para>
                  Creates a human-readable string that represents this
               <see cref='T:Love.Size'/>.
               </para>
            </summary>
        </member>
        <member name="M:Love.Size.Multiply(Love.Size,System.Int32)">
            <summary>
            Multiplies <see cref="T:Love.Size"/> by an <see cref="T:System.Int32"/> producing <see cref="T:Love.Size"/>.
            </summary>
            <param name="size">Multiplicand of type <see cref="T:Love.Size"/>.</param>
            <param name="multiplier">Multiplier of type <see cref='T:System.Int32'/>.</param>
            <returns>Product of type <see cref="T:Love.Size"/>.</returns>
        </member>
        <member name="M:Love.Size.Multiply(Love.Size,System.Single)">
            <summary>
            Multiplies <see cref="T:Love.Size"/> by a <see cref="T:System.Single"/> producing <see cref="T:Love.SizeF"/>.
            </summary>
            <param name="size">Multiplicand of type <see cref="T:Love.Size"/>.</param>
            <param name="multiplier">Multiplier of type <see cref="T:System.Single"/>.</param>
            <returns>Product of type SizeF.</returns>
        </member>
        <member name="T:Love.SizeF">
            Represents a dimension in 2D coordinate space
            <summary>
               <para>
                  Represents the size of a rectangular region
                  with an ordered pair of width and height.
               </para>
            </summary>
        </member>
        <member name="F:Love.SizeF.Empty">
            <summary>
               Initializes a new instance of the <see cref='T:Love.SizeF'/> class.
            </summary>
        </member>
        <member name="M:Love.SizeF.#ctor(Love.SizeF)">
            Create a new SizeF object from another size object
            <summary>
               Initializes a new instance of the <see cref='T:Love.SizeF'/> class
               from the specified existing <see cref='T:Love.SizeF'/>.
            </summary>
        </member>
        <member name="M:Love.SizeF.#ctor(Love.Vector2)">
            Create a new SizeF object from a point
            <summary>
               <para>
                  Initializes a new instance of the <see cref='T:Love.SizeF'/> class from
                  the specified <see cref='!:System.Drawing.PointF'/>.
               </para>
            </summary>
        </member>
        <member name="M:Love.SizeF.#ctor(System.Single,System.Single)">
            Create a new SizeF object of the specified dimension
            <summary>
               <para>
                  Initializes a new instance of the <see cref='T:Love.SizeF'/> class from
                  the specified dimensions.
               </para>
            </summary>
        </member>
        <member name="M:Love.SizeF.op_Addition(Love.SizeF,Love.SizeF)">
            <summary>
               <para>
                  Performs vector addition of two <see cref='T:Love.SizeF'/> objects.
               </para>
            </summary>
        </member>
        <member name="M:Love.SizeF.op_Subtraction(Love.SizeF,Love.SizeF)">
            <summary>
               <para>
                  Contracts a <see cref='T:Love.SizeF'/> by another <see cref='T:Love.SizeF'/>
               </para>
            </summary>        
        </member>
        <member name="M:Love.SizeF.op_Multiply(System.Single,Love.SizeF)">
            <summary>
            Multiplies <see cref="T:Love.SizeF"/> by a <see cref="T:System.Single"/> producing <see cref="T:Love.SizeF"/>.
            </summary>
            <param name="left">Multiplier of type <see cref="T:System.Single"/>.</param>
            <param name="right">Multiplicand of type <see cref="T:Love.SizeF"/>.</param>
            <returns>Product of type <see cref="T:Love.SizeF"/>.</returns>
        </member>
        <member name="M:Love.SizeF.op_Multiply(Love.SizeF,System.Single)">
            <summary>
            Multiplies <see cref="T:Love.SizeF"/> by a <see cref="T:System.Single"/> producing <see cref="T:Love.SizeF"/>.
            </summary>
            <param name="left">Multiplicand of type <see cref="T:Love.SizeF"/>.</param>
            <param name="right">Multiplier of type <see cref="T:System.Single"/>.</param>
            <returns>Product of type <see cref="T:Love.SizeF"/>.</returns>
        </member>
        <member name="M:Love.SizeF.op_Division(Love.SizeF,System.Single)">
            <summary>
            Divides <see cref="T:Love.SizeF"/> by a <see cref="T:System.Single"/> producing <see cref="T:Love.SizeF"/>.
            </summary>
            <param name="left">Dividend of type <see cref="T:Love.SizeF"/>.</param>
            <param name="right">Divisor of type <see cref="T:System.Int32"/>.</param>
            <returns>Result of type <see cref="T:Love.SizeF"/>.</returns>
        </member>
        <member name="M:Love.SizeF.op_Equality(Love.SizeF,Love.SizeF)">
            <summary>
               Tests whether two <see cref='T:Love.SizeF'/> objects
               are identical.
            </summary>
        </member>
        <member name="M:Love.SizeF.op_Inequality(Love.SizeF,Love.SizeF)">
            <summary>
               <para>
                  Tests whether two <see cref='T:Love.SizeF'/> objects are different.
               </para>
            </summary>
        </member>
        <member name="M:Love.SizeF.op_Explicit(Love.SizeF)~Love.Vector2">
            <summary>
               <para>
                  Converts the specified <see cref='T:Love.SizeF'/> to a
               <see cref='!:System.Drawing.PointF'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.SizeF.IsEmpty">
            <summary>
               <para>
                  Tests whether this <see cref='T:Love.SizeF'/> has zero
                  width and height.
               </para>
            </summary>
        </member>
        <member name="P:Love.SizeF.Width">
            Horizontal dimension
            <summary>
               <para>
                  Represents the horizontal component of this
               <see cref='T:Love.SizeF'/>.
               </para>
            </summary>
        </member>
        <member name="P:Love.SizeF.Height">
            Vertical dimension
            <summary>
               <para>
                  Represents the vertical component of this
               <see cref='T:Love.SizeF'/>.
               </para>
            </summary>
        </member>
        <member name="M:Love.SizeF.Add(Love.SizeF,Love.SizeF)">
            <summary>
               <para>
                  Performs vector addition of two <see cref='T:Love.SizeF'/> objects.
               </para>
            </summary>
        </member>
        <member name="M:Love.SizeF.Subtract(Love.SizeF,Love.SizeF)">
            <summary>
               <para>
                  Contracts a <see cref='T:Love.SizeF'/> by another <see cref='T:Love.SizeF'/>
                  .
               </para>
            </summary>        
        </member>
        <member name="M:Love.SizeF.Equals(System.Object)">
            <summary>
               <para>
                  Tests to see whether the specified object is a
               <see cref='T:Love.SizeF'/> 
               with the same dimensions as this <see cref='T:Love.SizeF'/>.
            </para>
            </summary>
        </member>
        <member name="M:Love.SizeF.ToString">
            <summary>
               <para>
                  Creates a human-readable string that represents this
               <see cref='T:Love.SizeF'/>.
               </para>
            </summary>
        </member>
        <member name="M:Love.SizeF.Multiply(Love.SizeF,System.Single)">
            <summary>
            Multiplies <see cref="T:Love.SizeF"/> by a <see cref="T:System.Single"/> producing <see cref="T:Love.SizeF"/>.
            </summary>
            <param name="size">Multiplicand of type <see cref="T:Love.SizeF"/>.</param>
            <param name="multiplier">Multiplier of type <see cref="T:System.Single"/>.</param>
            <returns>Product of type SizeF.</returns>
        </member>
        <member name="F:Love.FileInfo.Size">
            <summary>
            Numbers will be -1 if they cannot be determined.
            </summary>
        </member>
        <member name="F:Love.FileInfo.ModifyTime">
            <summary>
            The file's last modification time in seconds since the unix epoch, or nil if it can't be determined.
            </summary>
        </member>
        <member name="F:Love.FileInfo.Type">
            <summary>
            The type of the object at the path (file, directory, symlink, etc.)
            </summary>
        </member>
        <member name="T:Love.WindowSettings">
            <summary>
            窗口属性
            </summary>
        </member>
        <member name="P:Love.WindowSettings.Fullscreen">
            <summary>
            Fullscreen (true), or windowed (false).
            </summary>
        </member>
        <member name="P:Love.WindowSettings.FullscreenType">
            <summary>
            Choose between "DeskTop" fullscreen or "Exclusive" fullscreen mode 
            </summary>
        </member>
        <member name="P:Love.WindowSettings.Vsync">
            <summary>
            True if LÖVE should wait for vsync, false otherwise.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.MSAA">
            <summary>
            The number of antialiasing samples.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.Stencil">
            <summary>
            Whether a stencil buffer should be allocated. If true, the stencil buffer will have 8 bits.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.Depth">
            <summary>
            The number of bits in the depth buffer.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.Resizable">
            <summary>
            Let the window be user-resizable
            </summary>
        </member>
        <member name="P:Love.WindowSettings.Borderless">
            <summary>
            Remove all border visuals from the window
            </summary>
        </member>
        <member name="P:Love.WindowSettings.Centered">
            <summary>
            True if the window should be centered.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.Display">
            <summary>
            The index of the display to show the window in, if multiple monitors are available.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.HighDpi">
            <summary>
            True if high-dpi mode should be used on Retina displays in macOS and iOS. Does nothing on non-Retina displays. Added in 0.9.1.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.MinWidth">
            <summary>
            The minimum width of the window, if it's resizable. Cannot be less than 1.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.MinHeight">
            <summary>
            The minimum height of the window, if it's resizable. Cannot be less than 1.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.UsePosition">
            <summary>
            True if use the position params, false otherwise.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.X">
            <summary>
            The x-coordinate of the window's position in the specified display. Added in 0.9.2.
            </summary>
        </member>
        <member name="P:Love.WindowSettings.Refreshrate">
            <summary>
            We don't explicitly set the refresh rate, it's "read-only".
            <para>The refresh rate of the screen's current display mode, in Hz. May be 0 if the value can't be determined. Added in 0.9.2.</para>
            </summary>
        </member>
        <member name="T:Love.Vertex">
            <summary>
            for Mesh function
            </summary>
        </member>
        <member name="F:Love.Vertex.pos">
            <summary>
            The position of the vertex .
            </summary>
        </member>
        <member name="F:Love.Vertex.uv">
            <summary>
            The u and v texture coordinate of the vertex. Texture coordinates are normally in the range of [0, 1], but can be greater or less (see WrapMode.)
            </summary>
        </member>
        <member name="F:Love.Vertex.color">
            <summary>
            The vertex color.
            </summary>
        </member>
        <member name="M:Love.Vertex.#ctor(Love.Vector2)">
            <summary>
            Mesh vertex.
            </summary>
            <param name="pos">The position of the vertex.</param>
        </member>
        <member name="M:Love.Vertex.#ctor(Love.Vector2,Love.Vector2,Love.Vector4)">
            <summary>
            Mesh vertex.
            </summary>
            <param name="pos">The position of the vertex.</param>
            <param name="uv">The u and vtexture coordinate of the vertex. Texture coordinates are normally in the range of [0, 1], but can be greater or less (see <see cref="T:Love.WrapMode"/>)  <para>https://love2d.org/wiki/WrapMode</para></param>
            <param name="color">The vertex color.</param>
        </member>
        <member name="M:Love.Viewport.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="x">The top-left corner along the x-axis.</param>
            <param name="y">The top-right corner along the y-axis.</param>
            <param name="w">The width of the viewport.</param>
            <param name="h">The height of the viewport.</param>
        </member>
        <member name="F:Love.Viewport.x">
            <summary>
            The top-left corner along the x-axis.
            </summary>
        </member>
        <member name="F:Love.Viewport.y">
            <summary>
            The top-right corner along the y-axis.
            </summary>
        </member>
        <member name="F:Love.Viewport.w">
            <summary>
            The width of the viewport.
            </summary>
        </member>
        <member name="F:Love.Viewport.h">
            <summary>
            The height of the viewport.
            </summary>
        </member>
        <member name="P:Love.Viewport.X">
            <summary>
            The top-left corner along the x-axis.
            </summary>
        </member>
        <member name="P:Love.Viewport.Y">
            <summary>
            The top-right corner along the y-axis.
            </summary>
        </member>
        <member name="P:Love.Viewport.Width">
            <summary>
            The width of the viewport.
            </summary>
        </member>
        <member name="P:Love.Viewport.Height">
            <summary>
            The height of the viewport.
            </summary>
        </member>
        <member name="M:Love.DllTool.GetUTF8Bytes(System.String)">
            <summary>
            <para>from C# string[] pass as char** to c language</para>
            </summary>
        </member>
        <member name="T:Love.Common">
            <summary>
            <para></para>
            <para></para>
            </summary>
        </member>
        <member name="M:Love.Common.GetVersion">
            <summary>
            Gets the current running version of LÖVE.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Common.GetVersionCodeName">
            <summary>
            Gets the current running version code of LÖVE.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Love.Timer">
            <summary>
            <para>提供高精度计时功能。</para>
            <para>Provides high-resolution timing functionality.</para>
            </summary>
        </member>
        <member name="M:Love.Timer.Step">
            <summary>
            Measures the time between two frames.
            </summary>
        </member>
        <member name="M:Love.Timer.GetDelta">
            <summary>
            Returns the time between the last two frames.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Timer.GetFPS">
            <summary>
            Returns the current frames per second.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Timer.GetAverageDelta">
            <summary>
            Returns the average delta time over the last second.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Timer.Sleep(System.Single)">
            <summary>
            Pauses the current thread for the specified amount of time.	
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:Love.Timer.GetTime">
            <summary>
            Returns the amount of time since some time in the past.		
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Keyboard.SetKeyRepeat(System.Boolean)">
            <summary>
            Enables or disables key repeat for love.keypressed. It is disabled by default.
            <para>The interval between repeats depends on the user's system settings. This function doesn't affect whether <see cref="M:Love.Scene.TextInput(System.String)"/> is called multiple times while a key is held down</para>
            </summary>
            <param name="enable">Whether repeat keypress events should be enabled when a key is held down.</param>
        </member>
        <member name="M:Love.Keyboard.HasKeyRepeat">
            <summary>
            Gets whether key repeat is enabled.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Keyboard.IsDown(Love.KeyConstant)">
            <summary>
            Checks whether a certain <see cref="T:Love.KeyConstant"/> is down. Not to be confused with <see cref="M:Love.Scene.KeyPressed(Love.KeyConstant,Love.Scancode,System.Boolean)"/> or <see cref="M:Love.Scene.KeyReleased(Love.KeyConstant,Love.Scancode)"/>.
            </summary>
            <param name="key_type">The key to check.</param>
            <returns>True if the key is down, false if not.</returns>
        </member>
        <member name="M:Love.Keyboard.IsScancodeDown(Love.Scancode)">
            <summary>
            Checks whether a certain <see cref="T:Love.Scancode"/> is down. Not to be confused with <see cref="M:Love.Scene.KeyPressed(Love.KeyConstant,Love.Scancode,System.Boolean)"/> or <see cref="M:Love.Scene.KeyReleased(Love.KeyConstant,Love.Scancode)"/>.
            <para>Unlike regular KeyConstants, Scancodes are keyboard layout-independent. The scancode "w" is used if the key in the same place as the "w" key on an American keyboard is pressed, no matter what the key is labelled or what the user's operating system settings are.</para>
            </summary>
            <param name="scancode_type"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Keyboard.GetScancodeFromKey(Love.KeyConstant)">
            <summary>
            Gets the hardware scancode corresponding to the given key.
            <para>Unlike <see cref="T:Love.KeyConstant"/>, <see cref="T:Love.Scancode"/> are keyboard layout-independent. For example the scancode "w" will be generated if the key in the same place as the "w" key on an American keyboard is pressed, no matter what the key is labelled or what the user's operating system settings are.</para>
            <para><see cref="T:Love.Scancode"/> are useful for creating default controls that have the same physical locations on on all systems.</para>
            </summary>
            <param name="key_type">The key to get the scancode from.</param>
            <returns>The scancode corresponding to the given key, or "unknown" if the given key has no known physical representation on the current system.</returns>
        </member>
        <member name="M:Love.Keyboard.GetKeyFromScancode(Love.Scancode)">
            <summary>
            <para>Gets the key corresponding to the given hardware scancode.</para>
            <para>Unlike <see cref="T:Love.KeyConstant"/>, <see cref="T:Love.Scancode"/> are keyboard layout-independent. For example the scancode "w" will be generated if the key in the same place as the "w" key on an American keyboard is pressed, no matter what the key is labelled or what the user's operating system settings are.</para>
            <para><see cref="T:Love.Scancode"/> are useful for creating default controls that have the same physical locations on on all systems.</para>
            </summary>
            <param name="scancode_type">The scancode to get the key from.</param>
            <returns>The key corresponding to the given <see cref="T:Love.Scancode"/> , or "unknown" if the <see cref="T:Love.Scancode"/> doesn't map to a KeyConstant on the current system.</returns>
        </member>
        <member name="M:Love.Keyboard.SetTextInput(System.Boolean)">
            <summary>
            <para>Enables or disables text input events. It is enabled by default on Windows, Mac, and Linux, and disabled by default on iOS and Android.</para>
            <para>On touch devices, this shows the system's native on-screen keyboard when it's enabled.</para>
            </summary>
            <param name="enable">Whether text input events should be enabled.</param>
        </member>
        <member name="M:Love.Keyboard.SetTextInput(System.Boolean,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            <para>Enables or disables text input events. It is enabled by default on Windows, Mac, and Linux, and disabled by default on iOS and Android.</para>
            <para>On iOS and Android this variant tells the OS that the specified rectangle is where text will show up in the game, which prevents the system on-screen keyboard from covering the text.</para>
            <para>On touch devices, this shows the system's native on-screen keyboard when it's enabled.</para>
            </summary>
            <param name="enable">Whether text input events should be enabled.</param>
            <param name="x">Text rectangle x position.</param>
            <param name="y">Text rectangle y position.</param>
            <param name="w">Text rectangle width.</param>
            <param name="h">Text rectangle height.</param>
        </member>
        <member name="M:Love.Keyboard.HasTextInput">
            <summary>
            Gets whether key repeat is enabled.
            </summary>
            <returns>Whether key repeat is enabled.</returns>
        </member>
        <member name="M:Love.Joystick.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="T:Love.Font">
            <summary>
            Allows you to work with fonts.
            <para>Defines the shape of characters that can be drawn onto the screen.</para>
            </summary>
        </member>
        <member name="M:Love.Font.NewRasterizer(Love.FileData)">
            <summary>
            Creates a new Rasterizer.
            </summary>
            <param name="fileData">The FileData of the font file.</param>
            <returns>The rasterizer.</returns>
        </member>
        <member name="M:Love.Font.NewTrueTypeRasterizer(Love.Data,System.Int32,Love.HintingMode)">
            <summary>
            Create a TrueTypeRasterizer with the font data.
            </summary>
            <param name="data">The data of to the TrueType font.</param>
            <param name="size">The font size.</param>
            <param name="hinting">True Type hinting mode.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Font.NewTrueTypeRasterizer(System.Int32,Love.HintingMode)">
            <summary>
            Create a TrueTypeRasterizer with the default font.
            </summary>
            <param name="size">The font size.</param>
            <param name="hinting">True Type hinting mode.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Font.NewBMFontRasterizer(Love.FileData,Love.ImageData[])">
            <summary>
            Creates a new BMFont Rasterizer.
            </summary>
            <param name="fileData">The file data of the BMFont.</param>
            <param name="imageDatas">The image data containing the drawable pictures of font glyphs.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Font.NewGlyphData(Love.Rasterizer,System.Byte[])">
            <summary>
            Creates a new GlyphData.
            </summary>
            <param name="rasterizer">The Rasterizer containing the font.</param>
            <param name="glyph">The character code of the glyph.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Font.NewGlyphData(Love.Rasterizer,System.Int32)">
            <summary>
            Creates a new GlyphData.
            </summary>
            <param name="rasterizer">The Rasterizer containing the font.</param>
            <param name="glyphCode">The character code of the glyph.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Font.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Font.GetHeight">
            <summary>
            Gets the height of the Font in pixels.
            </summary>
            <returns>The height of the Font in pixels.</returns>
        </member>
        <member name="M:Love.Font.GetWidth(System.Byte[])">
            <summary>
            Determines the width of the given text. (UTF-8 byte array version)
            </summary>
            <param name="str">A string. (UTF-8 byte array needed)</param>
            <returns>The width of the text.</returns>
        </member>
        <member name="M:Love.Font.SetLineHeight(System.Single)">
            <summary>
            Sets the line height. When rendering the font in lines the actual height will be determined by the line height multiplied by the height of the font. The default is 1.0.
            </summary>
            <param name="h">The new line height.</param>
        </member>
        <member name="M:Love.Font.GetLineHeight">
            <summary>
            Gets the line height. This will be the value previously set by <see cref="M:Love.Font.SetLineHeight(System.Single)"/>, or 1.0 by default.
            </summary>
            <returns>The current line height.</returns>
        </member>
        <member name="M:Love.Font.SetFilter(Love.FilterMode,Love.FilterMode,System.Single)">
            <summary>
            Sets the filter mode for a font.
            </summary>
            <param name="min_type">How to scale a font down.</param>
            <param name="mag_type">How to scale a font up.</param>
            <param name="anisotropy">Maximum amount of anisotropic filtering used.</param>
        </member>
        <member name="M:Love.Font.GetFilter(Love.FilterMode@,Love.FilterMode@,System.Single@)">
            <summary>
            Gets the filter mode for a font.
            </summary>
            <returns></returns>
            <param name="min_type">Filter mode used when minifying the font.</param>
            <param name="mag_type">Filter mode used when magnifying the font.</param>
            <param name="out_anisotropy">Maximum amount of anisotropic filtering used.</param>
        </member>
        <member name="M:Love.Font.GetAscent">
            <summary>
            Gets the ascent of the Font. The ascent spans the distance between the baseline and the top of the glyph that reaches farthest from the baseline.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Font.GetDescent">
            <summary>
            Gets the descent of the Font. The descent spans the distance between the baseline and the lowest descending glyph in a typeface.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Font.GetBaseline">
            <summary>
            Gets the baseline of the Font. Most scripts share the notion of a baseline: an imaginary horizontal line on which characters rest. In some scripts, parts of glyphs lie below the baseline.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Font.HasGlyphs(System.Byte[])">
            <summary>
            Gets whether the Font can render a character or string. (UTF-8 byte array version)
            </summary>
            <param name="str">A string. (UTF-8 byte array needed)</param>
            <returns>Whether the font can render all characters in the string.</returns>
        </member>
        <member name="M:Love.Font.SetFallbacks(Love.Font[])">
            <summary>
            Sets the fallback fonts. When the Font doesn't contain a glyph, it will substitute the glyph from the next subsequent fallback Fonts. This is akin to setting a "font stack" in Cascading Style Sheets (CSS).
            </summary>
            <param name="fallback">[The first fallback Font to use, ...Additional fallback Fonts.]</param>
        </member>
        <member name="M:Love.Font.NewGlyphData(Love.Rasterizer,System.String)">
            <summary>
            Creates a new GlyphData.
            </summary>
            <param name="rasterizer">The Rasterizer containing the font.</param>
            <param name="glyph">The character code of the glyph.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Font.NewRasterizer(System.String)">
            <summary>
            Creates a new Rasterizer.
            </summary>
            <param name="filename">The font file.</param>
            <returns>The rasterizer.</returns>
        </member>
        <member name="M:Love.Font.GetWidth(System.String)">
            <summary>
            Determines the width of the given text.
            </summary>
            <param name="str">A string.</param>
            <returns>The width of the text.</returns>
        </member>
        <member name="M:Love.Font.HasGlyphs(System.String)">
            <summary>
            Gets whether the Font can render a character or string.
            </summary>
            <param name="str">A string.</param>
            <returns>Whether the font can render all characters in the string.</returns>
        </member>
        <member name="M:Love.Font.GetWrap(System.String,System.Single)">
            <summary>
            Gets formatting information for text, given a wrap limit.
            </summary>
            <param name="text">The text that will be wrapped.</param>
            <param name="wrap_limit">The maximum width in pixels of each line that text is allowed before wrapping.</param>
            <returns>(The maximum width of the wrapped text., A sequence containing each line of text that was wrapped.)</returns>
        </member>
        <member name="M:Love.Mathf.Random(System.Single,System.Single)">
            <summary>
            Get uniformly distributed pseudo-random integer within [min, max].
            </summary>
            <param name="min">The minimum possible value it should return.</param>
            <param name="max">The maximum possible value it should return.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Mathf.Random">
            <summary>
            Get uniformly distributed pseudo-random real number within [0, 1].
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mathf.NewRandomGenerator">
            <summary>
            Creates a new RandomGenerator object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Mathf.NewBezierCurve(Love.Vector2[])">
            <summary>
            Creates a new BezierCurve object.
            <para>The number of vertices in the control polygon determines the degree of the curve, e.g. three vertices define a quadratic (degree 2) Bézier curve, four vertices define a cubic (degree 3) Bézier curve, etc.</para>
            </summary>
            <param name="points"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Mathf.Triangulate(Love.Vector2[])">
            <summary>
            Decomposes a simple polygon into triangles.
            </summary>
            <param name="points">Polygon to triangulate. Must not intersect itself.</param>
            <returns></returns>
        </member>
        <member name="M:Love.Mathf.IsConvex(Love.Vector2[])">
            <summary>
            <para>Checks whether a polygon is convex.</para>
            <para>PolygonShapes in love.physics, some forms of Meshes, and polygons drawn with love.graphics.polygon must be simple convex polygons.</para>
            </summary>
            <param name="points">The vertices of the polygon as a table in the form of {(x1, y1), (x2, y2), (x3, y3), ...}.</param>
            <returns>Whether the given polygon is convex.</returns>
        </member>
        <member name="M:Love.Mathf.GammaToLinear(System.Single)">
            <summary>
            <para>Converts a color from gamma-space (sRGB) to linear-space (RGB).</para>
            <para>This is useful when doing gamma-correct rendering and you need to do math in linear RGB in the few cases where LÖVE doesn't handle conversions automatically.</para>
            <para>Read more about gamma-correct rendering here(https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch24.html), here(http://filmicgames.com/archives/299), and here(http://renderwonk.com/blog/index.php/archive/adventures-with-gamma-correct-rendering/).</para>
            </summary>
            <param name="gama">The sRGB color to convert.</param>
            <returns>The color in gamma RGB space.</returns>
        </member>
        <member name="M:Love.Mathf.LinearToGamma(System.Single)">
            <summary>
            <para>Converts a color from linear-space (RGB) to gamma-space (sRGB). This is useful when storing linear RGB color values in an image, because the linear RGB color space has less precision than sRGB for dark colors, which can result in noticeable color banding when drawing.</para>
            <para>Read more about gamma-correct rendering here(https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch24.html), here(http://filmicgames.com/archives/299), and here(http://renderwonk.com/blog/index.php/archive/adventures-with-gamma-correct-rendering/).</para>
            </summary>
            <param name="liner">The RGB color to convert.</param>
            <returns>The color in gamma sRGB space.</returns>
        </member>
        <member name="M:Love.Mathf.Noise(System.Single)">
            <summary>
            <para>Generates Simplex noise from 1 dimension.</para>
            <para>Generates a Simplex or Perlin noise value in 1-4 dimensions. The return value will always be the same, given the same arguments.</para>
            <para>Simplex noise(http://en.wikipedia.org/wiki/Simplex_noise) is closely related to Perlin noise(http://en.wikipedia.org/wiki/Perlin_noise). It is widely used for procedural content generation.</para>
            <para>There are many webpages(http://libnoise.sourceforge.net/noisegen/) which discuss Perlin and Simplex noise in detail.</para>
            <para>The return value might be constant if only integer arguments are used. Avoid solely passing in integers, to get varying return values.</para>
            </summary>
            <param name="x">The number used to generate the noise value.</param>
            <returns>The noise value in the range of [0, 1].</returns>
        </member>
        <member name="M:Love.Mathf.Noise(System.Single,System.Single)">
            <summary>
            <para>Generates Simplex noise from 2 dimension.</para>
            <para>Generates a Simplex or Perlin noise value in 1-4 dimensions. The return value will always be the same, given the same arguments.</para>
            <para>Simplex noise(http://en.wikipedia.org/wiki/Simplex_noise) is closely related to Perlin noise(http://en.wikipedia.org/wiki/Perlin_noise). It is widely used for procedural content generation.</para>
            <para>There are many webpages(http://libnoise.sourceforge.net/noisegen/) which discuss Perlin and Simplex noise in detail.</para>
            <para>The return value might be constant if only integer arguments are used. Avoid solely passing in integers, to get varying return values.</para>
            </summary>
            <param name="x">The first value of the 2-dimensional vector used to generate the noise value.</param>
            <param name="y">The second value of the 2-dimensional vector used to generate the noise value.</param>
            <returns>The noise value in the range of [0, 1].</returns>
        </member>
        <member name="M:Love.Mathf.Noise(System.Single,System.Single,System.Single)">
            <summary>
            <para>Generates Simplex noise from 3 dimension.</para>
            <para>Generates a Simplex or Perlin noise value in 1-4 dimensions. The return value will always be the same, given the same arguments.</para>
            <para>Simplex noise(http://en.wikipedia.org/wiki/Simplex_noise) is closely related to Perlin noise(http://en.wikipedia.org/wiki/Perlin_noise). It is widely used for procedural content generation.</para>
            <para>There are many webpages(http://libnoise.sourceforge.net/noisegen/) which discuss Perlin and Simplex noise in detail.</para>
            <para>The return value might be constant if only integer arguments are used. Avoid solely passing in integers, to get varying return values.</para>
            </summary>
            <param name="x">The first value of the 3-dimensional vector used to generate the noise value.</param>
            <param name="y">The second value of the 3-dimensional vector used to generate the noise value.</param>
            <param name="z">The third value of the 3-dimensional vector used to generate the noise value.</param>
            <returns>The noise value in the range of [0, 1].</returns>
        </member>
        <member name="M:Love.Mathf.Noise(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            <para>Generates Simplex noise from 4 dimension.</para>
            <para>Generates a Simplex or Perlin noise value in 1-4 dimensions. The return value will always be the same, given the same arguments.</para>
            <para>Simplex noise(http://en.wikipedia.org/wiki/Simplex_noise) is closely related to Perlin noise(http://en.wikipedia.org/wiki/Perlin_noise). It is widely used for procedural content generation.</para>
            <para>There are many webpages(http://libnoise.sourceforge.net/noisegen/) which discuss Perlin and Simplex noise in detail.</para>
            <para>The return value might be constant if only integer arguments are used. Avoid solely passing in integers, to get varying return values.</para>
            </summary>
            <param name="x">The first value of the 4-dimensional vector used to generate the noise value.</param>
            <param name="y">The second value of the 4-dimensional vector used to generate the noise value.</param>
            <param name="z">The third value of the 4-dimensional vector used to generate the noise value.</param>
            <param name="w">The fourth value of the 4-dimensional vector used to generate the noise value.</param>
            <returns>The noise value in the range of [0, 1].</returns>
        </member>
        <member name="F:Love.Mathf.Deg2Rad">
            <summary>
            Degrees-to-radians conversion constant.
            </summary>
        </member>
        <member name="F:Love.Mathf.Deg2Grad">
            <summary>
            Degrees-to-grad conversion constant.
            </summary>
        </member>
        <member name="F:Love.Mathf.Epsilon">
            <summary>
            A tiny floating point value.
            </summary>
        </member>
        <member name="F:Love.Mathf.ExponentialE">
            <summary>
            Exponential e.
            </summary>
        </member>
        <member name="F:Love.Mathf.GoldenRatio">
            <summary>
            The golden ratio. Oooooh!
            </summary>
        </member>
        <member name="F:Love.Mathf.Grad2Deg">
            <summary>
            Grad-to-degrees conversion constant.
            </summary>
        </member>
        <member name="F:Love.Mathf.Grad2Rad">
            <summary>
            Grad-to-radians conversion constant.
            </summary>
        </member>
        <member name="F:Love.Mathf.Infinity">
            <summary>
            A representation of positive infinity.
            </summary>
        </member>
        <member name="F:Love.Mathf.NegativeInfinity">
            <summary>
            A representation of negative infinity.
            </summary>
        </member>
        <member name="F:Love.Mathf.PI">
            <summary>
            The infamous 3.14159265358979... value.
            </summary>
        </member>
        <member name="F:Love.Mathf.Rad2Deg">
            <summary>
            Radians-to-degrees conversion constant.
            </summary>
        </member>
        <member name="F:Love.Mathf.Rad2Grad">
            <summary>
            Radians-to-grad conversion constant.
            </summary>
        </member>
        <member name="F:Love.Mathf.TAU">
            <summary>
            The not-so-infamous TAU value.
            </summary>
        </member>
        <member name="M:Love.Mathf.Abs(System.Int32)">
            <summary>
            Returns the absolute value of a.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.Abs(System.Single)">
            <summary>
            Returns the absolute value of a.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.Acos(System.Single)">
            <summary>
            Returns the arc-cosine of a - the angle in radians whose cosine is a.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.Approximately(System.Single,System.Single)">
            <summary>
            Returns if the two values are approximately close to eachother
            </summary>
            <param name="a">First value</param>
            <param name="b">Second value</param>
        </member>
        <member name="M:Love.Mathf.Asin(System.Single)">
            <summary>
            Returns the arc-sine of a - the angle in radians whose sine is a.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.Atan(System.Single)">
            <summary>
            Returns the arc-tangent of a - the angle in radians whose tangent is a.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.Atan2(System.Single,System.Single)">
            <summary>
            Returns the angle in radians whose Tan is y/x.
            </summary>
            <param name="y">The y value</param>
            <param name="x">The x value</param>
        </member>
        <member name="M:Love.Mathf.Ceil(System.Single)">
            <summary>
            Returns the smallest integer greater to or equal to a.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.CeilToInt(System.Single)">
            <summary>
            Returns the smallest integer greater to or equal to a.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>
            Clamps a value between a minimum int and maximum int value.
            </summary>
            <param name="value">The value</param>
            <param name="min">The minimum value</param>
            <param name="max">The maximum value</param>
        </member>
        <member name="M:Love.Mathf.Clamp(System.Single,System.Single,System.Single)">
            <summary>
            Clamps a value between a minimum float and maximum float value.
            </summary>
            <param name="value">The value</param>
            <param name="min">The minimum value</param>
            <param name="max">The maximum value</param>
        </member>
        <member name="M:Love.Mathf.Clamp01(System.Single)">
            <summary>
            Clamps value between 0 and 1 and returns value.
            </summary>
            <param name="value">The value</param>
        </member>
        <member name="M:Love.Mathf.ClosestPowerOfTwo(System.Int32)">
            <summary>
            Returns the closest power of two to a value.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.Cos(System.Single)">
            <summary>
            Returns the cosine of angle f in radians.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.Exp(System.Single)">
            <summary>
            Returns e raised to the specified power.
            </summary>
            <param name="power">The power</param>
        </member>
        <member name="M:Love.Mathf.Floor(System.Single)">
            <summary>
            Returns the largest integer smaller to or equal to a.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.FloorToInt(System.Single)">
            <summary>
            Returns the largest integer smaller to or equal to a.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.IsPowerOfTwo(System.Int32)">
            <summary>
            Returns if the value is powered by two.
            </summary>
            <param name="value">A value</param>
        </member>
        <member name="M:Love.Mathf.Lerp(System.Single,System.Single,System.Single)">
            <summary>
            Interpolates between from and to by t. t is clamped between 0 and 1.
            </summary>
            <param name="from">The from value</param>
            <param name="to">The to value</param>
            <param name="t">The t value</param>
        </member>
        <member name="M:Love.Mathf.Log(System.Single)">
            <summary>
            Returns the natural (base e) logarithm of a specified value.
            </summary>
            <param name="value">The value</param>
        </member>
        <member name="M:Love.Mathf.Log10(System.Single)">
            <summary>
            Returns the base 10 logarithm of a specified value.
            </summary>
            <param name="value">The value</param>
        </member>
        <member name="M:Love.Mathf.Max(System.Int32,System.Int32)">
            <summary>
            Returns the largest of two integer values.
            </summary>
            <param name="a">First value</param>
            <param name="b">Second value</param>
        </member>
        <member name="M:Love.Mathf.Max(System.Single,System.Single)">
            <summary>
            Returns the largest of two float values.
            </summary>
            <param name="a">First value</param>
            <param name="b">Second value</param>
        </member>
        <member name="M:Love.Mathf.Max(System.Int32[])">
            <summary>
            Returns the largest of a set of integer values.
            </summary>
            <param name="values">The set of values</param>
        </member>
        <member name="M:Love.Mathf.Max(System.Single[])">
            <summary>
            Returns the largest of a set of float values.
            </summary>
            <param name="values">The set of values</param>
        </member>
        <member name="M:Love.Mathf.Min(System.Int32,System.Int32)">
            <summary>
            Returns the smaller of two integer values.
            </summary>
            <param name="a">First value</param>
            <param name="b">Second value</param>
        </member>
        <member name="M:Love.Mathf.Min(System.Single,System.Single)">
            <summary>
            Returns the smaller of two float values.
            </summary>
            <param name="a">First value</param>
            <param name="b">Second value</param>
        </member>
        <member name="M:Love.Mathf.NextPowerOfTwo(System.Int32)">
            <summary>
            Get the next power of two after a value.
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:Love.Mathf.Pow(System.Single,System.Single)">
            <summary>
            Returns f raised to power p.
            </summary>
            <param name="f">The value to raise</param>
            <param name="p">The power</param>
        </member>
        <member name="M:Love.Mathf.RoughlyEqual(System.Single,System.Single,System.Single)">
            <summary>
            Compares two floating point values if they are similar.
            </summary>
            <param name="a">First value</param>
            <param name="b">Second value</param>
            <param name="threshold">The threshold of similarity</param>
            <returns>True if the values are similar, otherwise false.</returns>
        </member>
        <member name="M:Love.Mathf.Round(System.Single)">
            <summary>
            Returns f rounded to the nearest integer.
            </summary>
            <param name="f">The value</param>
        </member>
        <member name="M:Love.Mathf.Round(System.Single,System.Int32)">
            <summary>
            Rounds a floating-point value to a specified number of fractional digits. 
            </summary>
            <param name="f">The value</param>
            <param name="decimals">The number of fractional digits to round to</param>
        </member>
        <member name="M:Love.Mathf.Round(System.Single,System.Int32,System.MidpointRounding)">
            <summary>
            Rounds a floating-point value to a specified number of fractional digits. A parameter specifies how to round a value if it is midway between two other numbers.
            </summary>
            <param name="f">The value</param>
            <param name="decimals">The number of fractional digits to round to</param>
            <param name="mode">The rounding mode to use</param>
        </member>
        <member name="M:Love.Mathf.RoundToInt(System.Single)">
            <summary>
            Returns f rounded to the nearest integer.
            </summary>
            <param name="f">The value to round</param>
        </member>
        <member name="M:Love.Mathf.RoundToInt(System.Single,System.MidpointRounding)">
            <summary>
             Rounds a floating-point value. A parameter specifies how to round a value if it is midway between two other numbers.
            </summary>
            <param name="f">The value</param>
            <param name="mode">The rounding mode to use</param>
        </member>
        <member name="M:Love.Mathf.Sign(System.Single)">
            <summary>
            Returns the sign of f.
            </summary>
            <param name="f">The value</param>
        </member>
        <member name="M:Love.Mathf.Sin(System.Single)">
            <summary>
            Returns the sine of angle f in radians.
            </summary>
            <param name="f">The value</param>
        </member>
        <member name="M:Love.Mathf.Sqrt(System.Single)">
            <summary>
            Returns square root of f.
            </summary>
            <param name="f">The value</param>
        </member>
        <member name="M:Love.Mathf.Tan(System.Single)">
            <summary>
            Returns the tangent of angle f in radians.
            </summary>
            <param name="f">The value</param>
        </member>
        <member name="M:Love.Mathf.SmoothStep(System.Single,System.Single,System.Single)">
            <summary>
            Interpolates between min and max with smoothing at the limits.
            This function interpolates between min and max in a similar way to Lerp.
            However, the interpolation will gradually speed up from the start and slow down toward the end.
            This is useful for creating natural-looking animation, fading and other transitions.
            </summary>
            <param name="value1"></param>
            <param name="value2"></param>
            <param name="amount"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Mathf.CatmullRom(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Using formula from http://www.mvps.org/directx/articles/catmull/
            </summary>
            <param name="value1"></param>
            <param name="value2"></param>
            <param name="value3"></param>
            <param name="value4"></param>
            <param name="amount"></param>
            <returns></returns>
        </member>
        <member name="T:Love.Scene">
            <summary>
            <para>继承本类，作为 Boot.Run 的启动参数。</para>
            <para>Inherit this class as the startup parameter for Boot.Run()</para>
            </summary>
        </member>
        <member name="M:Love.Scene.KeyPressed(Love.KeyConstant,Love.Scancode,System.Boolean)">
            <summary>
            Triggered when a key is pressed.
            </summary>
            <param name="key">Character of the pressed key.</param>
            <param name="scancode">The scancode representing the pressed key.</param>
            <param name="isRepeat">Whether this keypress event is a repeat. The delay between key repeats depends on the user's system settings.</param>
        </member>
        <member name="M:Love.Scene.KeyReleased(Love.KeyConstant,Love.Scancode)">
            <summary>
            Triggered when a keyboard key is released.
            </summary>
            <param name="key">Character of the pressed key.</param>
            <param name="scancode">The scancode representing the pressed key.</param>
        </member>
        <member name="M:Love.Scene.MouseMoved(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            Callback function triggered when the mouse is moved.
            </summary>
            <param name="x">The mouse position on the x-axis.</param>
            <param name="y">The mouse position on the y-axis.</param>
            <param name="dx">The amount moved along the x-axis since the last time love.mousemoved was called.</param>
            <param name="dy">The amount moved along the y-axis since the last time love.mousemoved was called.</param>
            <param name="isTouch">True if the mouse button press originated from a touchscreen touch-press.</param>
        </member>
        <member name="M:Love.Scene.MousePressed(System.Single,System.Single,System.Int32,System.Boolean)">
            <summary>
            Callback function triggered when a mouse button is pressed.
            </summary>
            <param name="x">Mouse x position, in pixels.</param>
            <param name="y">Mouse y position, in pixels.</param>
            <param name="button">The button index that was pressed. 1 is the primary mouse button, 2 is the secondary mouse button and 3 is the middle button. Further buttons are mouse dependent.</param>
            <param name="isTouch">True if the mouse button press originated from a touchscreen touch-press.</param>
        </member>
        <member name="M:Love.Scene.MouseReleased(System.Single,System.Single,System.Int32,System.Boolean)">
            <summary>
            Callback function triggered when a mouse button is released.
            </summary>
            <param name="x">Mouse x position, in pixels.</param>
            <param name="y">Mouse y position, in pixels.</param>
            <param name="button">The button index that was pressed. 1 is the primary mouse button, 2 is the secondary mouse button and 3 is the middle button. Further buttons are mouse dependent.</param>
            <param name="isTouch">True if the mouse button press originated from a touchscreen touch-press.</param>
        </member>
        <member name="M:Love.Scene.MouseFocus(System.Boolean)">
            <summary>
            Callback function triggered when window receives or loses mouse focus.
            </summary>
            <param name="focus">Whether the window has mouse focus or not.</param>
        </member>
        <member name="M:Love.Scene.WheelMoved(System.Int32,System.Int32)">
            <summary>
            Callback function triggered when the mouse wheel is moved.
            </summary>
            <param name="x">Amount of horizontal mouse wheel movement. Positive values indicate movement to the right.</param>
            <param name="y">Amount of vertical mouse wheel movement. Positive values indicate upward movement.</param>
        </member>
        <member name="M:Love.Scene.JoystickPressed(Love.Joystick,System.Int32)">
            <summary>
            Called when a joystick button is pressed.
            </summary>
            <param name="joystick">The joystick object.</param>
            <param name="button">The button number.</param>
        </member>
        <member name="M:Love.Scene.JoystickReleased(Love.Joystick,System.Int32)">
            <summary>
            Called when a joystick button is released.
            </summary>
            <param name="joystick">The joystick object.</param>
            <param name="button">The button number.</param>
        </member>
        <member name="M:Love.Scene.JoystickAxis(Love.Joystick,System.Single,System.Single)">
            <summary>
            Called when a joystick axis moves.
            </summary>
            <param name="joystick">The joystick object.</param>
            <param name="axis">The axis number.</param>
            <param name="value">The new axis value.</param>
        </member>
        <member name="M:Love.Scene.JoystickHat(Love.Joystick,System.Int32,Love.JoystickHat)">
            <summary>
            Called when a joystick hat direction changes.
            </summary>
            <param name="joystick">The joystick object.</param>
            <param name="hat">The hat number.</param>
            <param name="direction">The new hat direction.</param>
        </member>
        <member name="M:Love.Scene.JoystickGamepadPressed(Love.Joystick,Love.GamepadButton)">
            <summary>
            Called when a Joystick's virtual gamepad button is pressed.
            </summary>
            <param name="joystick">The joystick object.</param>
            <param name="button">The virtual gamepad button.</param>
        </member>
        <member name="M:Love.Scene.JoystickGamepadReleased(Love.Joystick,Love.GamepadButton)">
            <summary>
            Called when a Joystick's virtual gamepad button is released.
            </summary>
            <param name="joystick">The joystick object.</param>
            <param name="button">The virtual gamepad button.</param>
        </member>
        <member name="M:Love.Scene.JoystickGamepadAxis(Love.Joystick,Love.GamepadAxis,System.Single)">
            <summary>
            Called when a Joystick's virtual gamepad axis is moved.
            </summary>
            <param name="joystick">The joystick object.</param>
            <param name="axis">The virtual gamepad axis.</param>
            <param name="value">The new axis value.</param>
        </member>
        <member name="M:Love.Scene.JoystickAdded(Love.Joystick)">
            <summary>
            Called when a Joystick is connected.
            </summary>
            <param name="joystick">The newly connected Joystick object.</param>
        </member>
        <member name="M:Love.Scene.JoystickRemoved(Love.Joystick)">
            <summary>
            Called when a Joystick is disconnected.
            </summary>
            <param name="joystick">The now-disconnected Joystick object.</param>
        </member>
        <member name="M:Love.Scene.TouchMoved(System.Int64,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Callback function triggered when a touch press moves inside the touch screen.
            </summary>
            <param name="id">The identifier for the touch press.</param>
            <param name="x">The x-axis position of the touch inside the window, in pixels.</param>
            <param name="y">The y-axis position of the touch inside the window, in pixels.</param>
            <param name="dx">The x-axis movement of the touch inside the window, in pixels.</param>
            <param name="dy">The y-axis movement of the touch inside the window, in pixels.</param>
            <param name="pressure">The amount of pressure being applied. Most touch screens aren't pressure sensitive, in which case the pressure will be 1.</param>
        </member>
        <member name="M:Love.Scene.TouchPressed(System.Int64,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Callback function triggered when the touch screen is touched.
            </summary>
            <param name="id">The identifier for the touch press.</param>
            <param name="x">The x-axis position of the touch inside the window, in pixels.</param>
            <param name="y">The y-axis position of the touch inside the window, in pixels.</param>
            <param name="dx">The x-axis movement of the touch inside the window, in pixels.</param>
            <param name="dy">The y-axis movement of the touch inside the window, in pixels.</param>
            <param name="pressure">The amount of pressure being applied. Most touch screens aren't pressure sensitive, in which case the pressure will be 1.</param>
        </member>
        <member name="M:Love.Scene.TouchReleased(System.Int64,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Callback function triggered when the touch screen stops being touched.
            </summary>
            <param name="id">The identifier for the touch press.</param>
            <param name="x">The x-axis position of the touch inside the window, in pixels.</param>
            <param name="y">The y-axis position of the touch inside the window, in pixels.</param>
            <param name="dx">The x-axis movement of the touch inside the window, in pixels.</param>
            <param name="dy">The y-axis movement of the touch inside the window, in pixels.</param>
            <param name="pressure">The amount of pressure being applied. Most touch screens aren't pressure sensitive, in which case the pressure will be 1.</param>
        </member>
        <member name="M:Love.Scene.TextEditing(System.String,System.Int32,System.Int32)">
            <summary>
            Called when the candidate text for an IME has changed.
            </summary>
            <param name="text">The UTF-8 encoded unicode candidate text.</param>
            <param name="start">The start cursor of the selected candidate text.</param>
            <param name="end">The length of the selected candidate text. May be 0.</param>
        </member>
        <member name="M:Love.Scene.TextInput(System.String)">
            <summary>
            Called when text has been entered by the user.
            </summary>
            <param name="text">The UTF-8 encoded unicode text.</param>
        </member>
        <member name="M:Love.Scene.WindowFocus(System.Boolean)">
            <summary>
            Callback function triggered when window receives or loses focus.
            </summary>
            <param name="focus">True if the window gains focus, false if it loses focus.</param>
        </member>
        <member name="M:Love.Scene.WindowVisible(System.Boolean)">
            <summary>
            Callback function triggered when window is shown or hidden.
            </summary>
            <param name="visible">True if the window is visible, false if it isn't.</param>
        </member>
        <member name="M:Love.Scene.WindowResize(System.Int32,System.Int32)">
            <summary>
            Called when the window is resized, for example if the user resizes the window, or if Love.Window.SetMode is called with an unsupported width or height in fullscreen and the window chooses the closest appropriate size.
            </summary>
            <param name="w">The new width, in pixels.</param>
            <param name="h">The new height, in pixels.</param>
        </member>
        <member name="M:Love.Scene.DirectoryDropped(System.String)">
            <summary>
            Callback function triggered when a directory is dragged and dropped onto the window.
            </summary>
            <param name="path">The full platform-dependent path to the directory. It can be used as an argument to love.filesystem.mount, in order to gain read access to the directory with love.filesystem.</param>
        </member>
        <member name="M:Love.Scene.FileDropped(Love.File)">
            <summary>
            Callback function triggered when a file is dragged and dropped onto the window.
            </summary>
            <param name="file">The unopened File object representing the file that was dropped.</param>
        </member>
        <member name="M:Love.Scene.Quit">
            <summary>
            Callback function triggered when the game is closed.
            </summary>
            <returns>Abort quitting. If true, do not close the game.</returns>
        </member>
        <member name="M:Love.Scene.LowMemory">
            <summary>
            Callback function triggered when the system is running out of memory on mobile devices.
            </summary>
        </member>
        <member name="M:Love.Scene.Load">
            <summary>
            This function is called exactly once at the beginning of the game.
            </summary>
        </member>
        <member name="M:Love.Scene.Update(System.Single)">
            <summary>
            Callback function used to update the state of the game every frame.
            </summary>
            <param name="dt">Time since the last update in seconds.</param>
        </member>
        <member name="M:Love.Scene.Draw">
            <summary>
            Callback function used to draw on the screen every frame.
            </summary>
        </member>
        <member name="M:Love.Scene.ErrorHandler(System.Exception)">
            <summary>
            Callback function when exception occur.
            Return true means exit error screen.
            This function will be called each error screen render frame.
            </summary>
        </member>
        <member name="T:Love.BootConfig">
            <summary>
            Boot class start params
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowWidth">
            <summary>
            The window width(height)
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowHeight">
            <summary>
            The window width(height)
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowTitle">
            <summary>
            The window title
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowBorderless">
            <summary>
            Remove all border visuals from the window
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowResizable">
            <summary>
            Let the window be user-resizable
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowMinWidth">
            <summary>
            Minimum window width if the window is resizable
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowMinHeight">
            <summary>
            Minimum window height if the window is resizable
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowFullscreen">
            <summary>
            Choose between "DeskTop" fullscreen or "Exclusive" fullscreen mode 
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowVsync">
            <summary>
            Vertical sync mode
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowMSAA">
            <summary>
            The number of samples to use with multi-sampled antialiasing
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowDisplay">
            <summary>
            Index of the monitor to show the window in
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowHighdpi">
            <summary>
            Enable high-dpi mode for the window on a Retina display
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowX">
            <summary>
            The x-coordinate(y-coordinate) of the window's position in the specified display
            </summary>
        </member>
        <member name="F:Love.BootConfig.WindowY">
            <summary>
            The x-coordinate(y-coordinate) of the window's position in the specified display
            </summary>
        </member>
        <member name="T:Love.Boot">
            <summary>
            LÖVE engine entrance class
            <para>LÖVE 引擎入口类</para> 
            </summary>
        </member>
        <member name="M:Love.Boot.Run(Love.Scene,Love.BootConfig)">
            <summary>
            LÖVE engine entrance function
            </summary>
            <param name="scene">The way to run LÖVE engine</param>
            <param name="bootConfig">LÖVE engine boot config</param>
        </member>
        <member name="M:Love.Half.IntToFloat(System.Int32)">
            <summary>
            ignores the higher 16 bits
            <para>https://codereview.stackexchange.com/questions/45007/half-precision-reader-writer-for-c</para>
            </summary>
            <param name="hbits"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Half.FloatToInt(System.Single)">
            <summary>
            returns all higher 16 bits as 0 for all results
            <para>https://codereview.stackexchange.com/questions/45007/half-precision-reader-writer-for-c</para>
            </summary>
            <param name="fval"></param>
            <returns></returns>
        </member>
        <member name="T:Love.Pixel">
            <summary>
            <code>
            union Pixel
            {
                uint8 rgba8 [4];
                uint16 rgba16 [4];
                half rgba16f [4];
                float  rgba32f [4];
            };
            </code>
            </summary>
        </member>
        <member name="M:Love.Pixel.FromFloat4(Love.Vector4,Love.PixelFormat)">
            <summary>
            Create pixel with given Float4 value and format
            </summary>
            <param name="value"></param>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="T:Love.HintingMode">
            <summary>
            True Type hinting mode. See True Type official document for more information.
            </summary>
        </member>
        <member name="T:Love.GamepadButton">
            <summary>
            Virtual gamepad buttons.
            </summary>
        </member>
        <member name="F:Love.GamepadButton.LeftStick">
            <summary>
            Left stick click button.
            </summary>
        </member>
        <member name="F:Love.GamepadButton.RightStick">
            <summary>
            Right stick click button.
            </summary>
        </member>
        <member name="F:Love.GamepadButton.LeftShoulder">
            <summary>
            Left bumper.
            </summary>
        </member>
        <member name="F:Love.GamepadButton.RightShoulder">
            <summary>
            Right bumper.
            </summary>
        </member>
        <member name="F:Love.GamepadButton.DPadUp">
            <summary>
            D-pad up.
            </summary>
        </member>
        <member name="F:Love.GamepadButton.DPadDown">
            <summary>
            D-pad down.
            </summary>
        </member>
        <member name="F:Love.GamepadButton.DPadLeft">
            <summary>
            D-pad left.
            </summary>
        </member>
        <member name="F:Love.GamepadButton.DPadRight">
            <summary>
            D-pad right.
            </summary>
        </member>
        <member name="T:Love.GamepadAxis">
            <summary>
            Virtual gamepad axes.
            </summary>
        </member>
        <member name="F:Love.JoystickHat.RightUp">
            <summary>
            Right+Up
            </summary>
        </member>
        <member name="F:Love.JoystickHat.RightDown">
            <summary>
            Right+Down
            </summary>
        </member>
        <member name="F:Love.JoystickHat.LeftUp">
            <summary>
            Left+Up
            </summary>
        </member>
        <member name="F:Love.JoystickHat.LeftDown">
            <summary>
            Left+Down
            </summary>
        </member>
        <member name="T:Love.ParticleInsertMode">
            <summary>
            How newly created particles are added to the ParticleSystem.
            </summary>
        </member>
        <member name="F:Love.ParticleInsertMode.Top">
            <summary>
            Particles are inserted at the top of the ParticleSystem's list of particles.
            </summary>
        </member>
        <member name="F:Love.ParticleInsertMode.Bottom">
            <summary>
            Particles are inserted at the bottom of the ParticleSystem's list of particles.
            </summary>
        </member>
        <member name="F:Love.ParticleInsertMode.Random">
            <summary>
            Particles are inserted at random positions in the ParticleSystem's list of particles.
            </summary>
        </member>
        <member name="T:Love.WrapMode">
            <summary>
            How the image wraps inside a Quad with a larger quad size than image size. This also affects how Meshes with texture coordinates which are outside the range of [0, 1] are drawn, and the color returned by the Texel Shader function when using it to sample from texture coordinates outside of the range of [0, 1].
            <para>https://love2d.org/wiki/WrapMode</para>
            </summary>
        </member>
        <member name="F:Love.WrapMode.Clamp">
            <summary>
            Clamp the texture. Appears only once. The area outside the texture's normal range is colored based on the edge pixels of the texture.
            </summary>
        </member>
        <member name="F:Love.WrapMode.ClampZero">
            <summary>
            Clamp the texture. Fills the area outside the texture's normal range with transparent black (or opaque black for textures with no alpha channel.)
            </summary>
        </member>
        <member name="F:Love.WrapMode.Repeat">
            <summary>
            Repeat the texture. Fills the whole available extent.
            </summary>
        </member>
        <member name="F:Love.WrapMode.MirroredRepeat">
            <summary>
            Repeat the texture, flipping it each time it repeats. May produce better visual results than the <see cref="F:Love.WrapMode.Repeat"/> mode when the texture doesn't seamlessly tile.
            </summary>
        </member>
        <member name="T:Love.FilterMode">
            <summary>
            How the image is filtered when scaling.
            </summary>
        </member>
        <member name="F:Love.FilterMode.Linear">
            <summary>
            Scale image with linear interpolation. (default)
            </summary>
        </member>
        <member name="F:Love.FilterMode.Nearest">
            <summary>
            Scale image with nearest neighbor interpolation.
            </summary>
        </member>
        <member name="T:Love.AlignMode">
            <summary>
            Text alignment.
            </summary>
        </member>
        <member name="F:Love.AlignMode.Left">
            <summary>
            Align text left.
            </summary>
        </member>
        <member name="F:Love.AlignMode.Center">
            <summary>
            Align text center.
            </summary>
        </member>
        <member name="F:Love.AlignMode.Right">
            <summary>
            Align text right.
            </summary>
        </member>
        <member name="F:Love.AlignMode.Justify">
            <summary>
            Align text both left and right.
            </summary>
        </member>
        <member name="T:Love.ImageDataPixelFormat">
            <summary>
            Provide for custom image data, not all Pixel format support to create new custom imageData;
            </summary>
        </member>
        <member name="T:Love.ImageFormat">
            <summary>
            Encoded image formats.
            </summary>
        </member>
        <member name="F:Love.ImageFormat.TGA">
            <summary>
            Targa image format.
            </summary>
        </member>
        <member name="F:Love.ImageFormat.PNG">
            <summary>
            PNG image format.
            </summary>
        </member>
        <member name="T:Love.FileMode">
            <summary>
            The different modes you can open a File in.
            </summary>
        </member>
        <member name="F:Love.FileMode.Closed">
            <summary>
            Do not open a file (represents a closed file.)
            </summary>
        </member>
        <member name="F:Love.FileMode.Read">
            <summary>
            Open a file for read.
            </summary>
        </member>
        <member name="F:Love.FileMode.Write">
            <summary>
            Open a file for write.
            </summary>
        </member>
        <member name="F:Love.FileMode.Append">
            <summary>
            Open a file for append.
            </summary>
        </member>
        <member name="T:Love.BufferMode">
            <summary>
            Buffer modes for File objects.
            </summary>
        </member>
        <member name="F:Love.BufferMode.None">
            <summary>
            No buffering. The result of write and append operations appears immediately.
            </summary>
        </member>
        <member name="F:Love.BufferMode.Line">
            <summary>
            Line buffering. Write and append operations are buffered until a newline is output or the buffer size limit is reached.
            </summary>
        </member>
        <member name="F:Love.BufferMode.Full">
            <summary>
            Full buffering. Write and append operations are always buffered until the buffer size limit is reached.
            </summary>
        </member>
        <member name="T:Love.FileType">
            <summary>
            The type of a file.
            </summary>
        </member>
        <member name="F:Love.FileType.File">
            <summary>
            Regular file.
            </summary>
        </member>
        <member name="F:Love.FileType.Directory">
            <summary>
            Directory.
            </summary>
        </member>
        <member name="F:Love.FileType.SymLink">
            <summary>
            Symbolic link.
            </summary>
        </member>
        <member name="F:Love.FileType.Other">
            <summary>
            Something completely different like a device.
            </summary>
        </member>
        <member name="T:Love.DistanceModel">
            <summary>
            The different distance models.
            <para>Extended information can be found in the chapter "3.4. Attenuation By Distance" of the OpenAL 1.1 specification.( https://www.openal.org/documentation/openal-1.1-specification.pdf )</para>
            </summary>
        </member>
        <member name="F:Love.DistanceModel.None">
            <summary>
            Sources do not get attenuated.
            </summary>
        </member>
        <member name="F:Love.DistanceModel.Inverse">
            <summary>
            Inverse distance attenuation.
            </summary>
        </member>
        <member name="F:Love.DistanceModel.InverseClamped">
            <summary>
            Inverse distance attenuation. Gain is clamped. In version 0.9.2 and older this is named inverse clamped.
            </summary>
        </member>
        <member name="F:Love.DistanceModel.Linear">
            <summary>
            Linear attenuation.
            </summary>
        </member>
        <member name="F:Love.DistanceModel.LinearClamped">
            <summary>
            Linear attenuation. Gain is clamped. In version 0.9.2 and older this is named linear clamped.
            </summary>
        </member>
        <member name="F:Love.DistanceModel.Exponent">
            <summary>
            Exponential attenuation.
            </summary>
        </member>
        <member name="F:Love.DistanceModel.ExponentClamped">
            <summary>
            Exponential attenuation. Gain is clamped. In version 0.9.2 and older this is named exponent clamped.
            </summary>
        </member>
        <member name="T:Love.SystemCursor">
            <summary>
            Types of cursors.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.Arrow">
            <summary>
            An arrow pointer.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.Ibeam">
            <summary>
            An I-beam, normally used when mousing over editable or selectable text.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.Wait">
            <summary>
            Wait graphic.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.Crosshair">
            <summary>
            Crosshair symbol.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.WaitArrow">
            <summary>
            Small wait cursor with an arrow pointer.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.SizeNWSE">
            <summary>
            Double arrow pointing to the top-left and bottom-right.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.SizeNESW">
            <summary>
            Double arrow pointing to the top-right and bottom-left.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.SizeWE">
            <summary>
            Double arrow pointing left and right.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.SizeNS">
            <summary>
            Double arrow pointing up and down.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.SizeAll">
            <summary>
            Four-pointed arrow pointing up, down, left, and right.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.No">
            <summary>
            Slashed circle or crossbones.
            </summary>
        </member>
        <member name="F:Love.SystemCursor.Hand">
            <summary>
            Hand symbol.
            </summary>
        </member>
        <member name="F:Love.CursorType.Custom">
            <summary>
            自定义的光标类型
            </summary>
        </member>
        <member name="F:Love.CursorType.System">
            <summary>
            系统的光标
            </summary>
        </member>
        <member name="T:Love.TimeUnit">
            <summary>
            Units that represent time.
            </summary>
        </member>
        <member name="F:Love.TimeUnit.Seconds">
            <summary>
            Regular seconds.
            </summary>
        </member>
        <member name="F:Love.TimeUnit.Samples">
            <summary>
            Audio samples.
            </summary>
        </member>
        <member name="T:Love.KeyConstant">
            <summary>
            All the keys you can press. Note that some keys may not be available on your keyboard or system.
            </summary>
        </member>
        <member name="T:Love.Scancode">
            <summary>
            <para>Scancodes are keyboard layout-independent, so the scancode "w" will be generated if the key in the same place as the "w" key on an American QWERTY keyboard ( https://en.wikipedia.org/wiki/Keyboard_layout#/media/File:ISO_keyboard_(105)_QWERTY_UK.svg )  is pressed, no matter what the key is labelled or what the user's operating system settings are.</para>
            <para>Using scancodes, rather than keycodes, is useful because keyboards with layouts differing from the US/UK layout(s) might have keys that generate 'unknown' keycodes, but the scancodes will still be detected. This however would necessitate having a list for each keyboard layout one would choose to support.</para>
            <para>One could use textinput or textedited instead, but those only give back the end result of keys used, i.e. you can't get modifiers on their own from it, only the final symbols that were generated.</para>
            </summary>
        </member>
        <member name="T:Love.SourceType">
            <summary>
            <para>Types of audio sources. </para>
            <para>A good rule of thumb is to use Stream for music files and Static for all short sound effects. Basically, you want to avoid loading large files into memory at once.</para>
            </summary>
        </member>
        <member name="F:Love.SourceType.Static">
            <summary>
            Decode the entire sound at once.
            </summary>
        </member>
        <member name="F:Love.SourceType.Stream">
            <summary>
            Stream the sound; decode it gradually.
            </summary>
        </member>
        <member name="F:Love.StackType.All">
            <summary>
            All Love.Graphics state, including transform state.
            </summary>
        </member>
        <member name="F:Love.StackType.Transform">
            <summary>
            The transformation stack (Love.Graphics.translate, Love.Graphics.rotate, etc.)
            </summary>
        </member>
        <member name="T:Love.FullscreenType">
            <summary>
            <para>全屏模式的类型。</para>
            <para>Types of fullscreen modes.</para>
            </summary>
        </member>
        <member name="F:Love.FullscreenType.Exclusive">
            <summary>
            Standard exclusive-fullscreen mode. Changes the display mode (actual resolution) of the monitor.
            </summary>
        </member>
        <member name="F:Love.FullscreenType.DeskTop">
            <summary>
            Sometimes known as borderless fullscreen windowed mode. A borderless screen-sized window is created which sits on top of all desktop UI elements. The window is automatically resized to match the dimensions of the desktop, and its size cannot be changed.
            </summary>
        </member>
        <member name="T:Love.MessageBoxType">
            <summary>
            <para>消息框对话框的类型。</para>
            <para>Types of message box dialogs.</para>
            </summary>
        </member>
        <member name="F:Love.MessageBoxType.Error">
            <summary>
            Error dialog.
            </summary>
        </member>
        <member name="F:Love.MessageBoxType.Warning">
            <summary>
            Warning dialog.
            </summary>
        </member>
        <member name="F:Love.MessageBoxType.Info">
            <summary>
            Informational dialog.
            </summary>
        </member>
        <member name="T:Love.ArcType">
            <summary>
            Different types of arcs that can be drawn.
            </summary>
        </member>
        <member name="F:Love.ArcType.Open">
            <summary>
            The arc circle's two end-points are unconnected when the arc is drawn as a line. Behaves like the "closed" arc type when the arc is drawn in filled mode.
            </summary>
        </member>
        <member name="F:Love.ArcType.Closed">
            <summary>
            The arc circle's two end-points are connected to each other.
            </summary>
        </member>
        <member name="F:Love.ArcType.Pie">
            <summary>
            The arc is drawn like a slice of pie, with the arc circle connected to the center at its end-points.
            </summary>
        </member>
        <member name="T:Love.BlendMode">
            <summary>
            Different ways to do color blending. See BlendAlphaMode and the BlendMode Formulas for additional notes.
            </summary>
        </member>
        <member name="F:Love.BlendMode.Alpha">
            <summary>
            Alpha blending (normal). The alpha of what's drawn determines its opacity.
            </summary>
        </member>
        <member name="F:Love.BlendMode.Add">
            <summary>
            The pixel colors of what's drawn are added to the pixel colors already on the screen. The alpha of the screen is not modified.
            </summary>
        </member>
        <member name="F:Love.BlendMode.Subtract">
            <summary>
            The pixel colors of what's drawn are subtracted from the pixel colors already on the screen. The alpha of the screen is not modified.
            </summary>
        </member>
        <member name="F:Love.BlendMode.Multiply">
            <summary>
            The pixel colors of what's drawn are multiplied with the pixel colors already on the screen (darkening them). The alpha of drawn objects is multiplied with the alpha of the screen rather than determining how much the colors on the screen are affected, even when the <see cref="F:Love.BlendAlphaMode.PreMultiplied"/> BlendAlphaMode is used.
            </summary>
        </member>
        <member name="F:Love.BlendMode.Lighten">
            <summary>
            The pixel colors of what's drawn are compared to the existing pixel colors, and the larger of the two values for each color component is used. Only works when the "premultiplied" BlendAlphaMode is used in <see cref="M:Love.Graphics.SetBlendMode(Love.BlendMode,Love.BlendAlphaMode)"/>
            </summary>
        </member>
        <member name="F:Love.BlendMode.Darken">
            <summary>
            The pixel colors of what's drawn are compared to the existing pixel colors, and the smaller of the two values for each color component is used. Only works when the "premultiplied" BlendAlphaMode is used in <see cref="M:Love.Graphics.SetBlendMode(Love.BlendMode,Love.BlendAlphaMode)"/>
            </summary>
        </member>
        <member name="F:Love.BlendMode.Screen">
            <summary>
            'Screen' blending.
            </summary>
        </member>
        <member name="F:Love.BlendMode.Replace">
            <summary>
            The colors of what's drawn completely replace what was on the screen, with no additional blending. The BlendAlphaMode specified in love.graphics.setBlendMode still affects what happens.
            </summary>
        </member>
        <member name="T:Love.BlendAlphaMode">
            <summary>
            The "premultiplied" constant should generally be used when drawing a Canvas to the screen, because the RGB values of the Canvas' texture had previously been multiplied by its alpha values when drawing content to the Canvas itself.
            <para>The "alphamultiply" constant does not affect the "multiply" BlendMode.Similarly, the "screen" BlendMode's math is only correct if the "premultiplied" alpha mode is used and the alpha of drawn objects has already been multiplied with its RGB values previously (possibly inside a shader).</para>
            <para>https://love2d.org/wiki/BlendAlphaMode</para>
            </summary>
        </member>
        <member name="F:Love.BlendAlphaMode.Multiply">
            <summary>
            The RGB values of what's drawn are multiplied by the alpha values of those colors during blending. This is the default alpha mode.
            </summary>
        </member>
        <member name="F:Love.BlendAlphaMode.PreMultiplied">
            <summary>
            The RGB values of what's drawn are not multiplied by the alpha values of those colors during blending. For most blend modes to work correctly with this alpha mode, the colors of a drawn object need to have had their RGB values multiplied by their alpha values at some point previously ("premultiplied alpha").
            </summary>
        </member>
        <member name="T:Love.LineStyle">
            <summary>
            The styles in which lines are drawn.
            </summary>
        </member>
        <member name="F:Love.LineStyle.Rough">
            <summary>
            Draw rough lines.
            </summary>
        </member>
        <member name="F:Love.LineStyle.Smooth">
            <summary>
            Draw smooth lines.
            </summary>
        </member>
        <member name="T:Love.LineJoin">
            <summary>
            https://love2d.org/wiki/LineJoin
            </summary>
        </member>
        <member name="F:Love.LineJoin.None">
            <summary>
            No cap applied to the ends of the line segments.
            <para>https://love2d.org/wiki/LineJoin</para>
            </summary>
        </member>
        <member name="F:Love.LineJoin.Miter">
            <summary>
            The ends of the line segments beveled in an angle so that they join seamlessly.
            <para>https://love2d.org/wiki/LineJoin</para>
            </summary>
        </member>
        <member name="F:Love.LineJoin.Bevel">
            <summary>
            Flattens the point where line segments join together.
            <para>https://love2d.org/wiki/LineJoin</para>
            </summary>
        </member>
        <member name="T:Love.StencilAction">
            <summary>
            <para>How a stencil function modifies the stencil values of pixels it touches.</para>
            https://love2d.org/wiki/StencilAction
            </summary>
        </member>
        <member name="F:Love.StencilAction.Replace">
            <summary>
            The stencil value of a pixel will be replaced by the value specified in love.graphics.stencil, if any object touches the pixel.
            </summary>
        </member>
        <member name="F:Love.StencilAction.Increment">
            <summary>
            The stencil value of a pixel will be incremented by 1 for each object that touches the pixel. If the stencil value reaches 255 it will stay at 255.
            </summary>
        </member>
        <member name="F:Love.StencilAction.Decrement">
            <summary>
            The stencil value of a pixel will be decremented by 1 for each object that touches the pixel. If the stencil value reaches 0 it will stay at 0.
            </summary>
        </member>
        <member name="F:Love.StencilAction.IncrementWrap">
            <summary>
            The stencil value of a pixel will be incremented by 1 for each object that touches the pixel. If a stencil value of 255 is incremented it will be set to 0.
            </summary>
        </member>
        <member name="F:Love.StencilAction.DecrementWrap">
            <summary>
            The stencil value of a pixel will be decremented by 1 for each object that touches the pixel. If the stencil value of 0 is decremented it will be set to 255.
            </summary>
        </member>
        <member name="F:Love.StencilAction.Invert">
            <summary>
            The stencil value of a pixel will be bitwise-inverted for each object that touches the pixel. If a stencil value of 0 is inverted it will become 255.
            </summary>
        </member>
        <member name="T:Love.CompareMode">
            <summary>
            Different types of per-pixel stencil test comparisons. The pixels of an object will be drawn if the comparison succeeds, for each pixel that the object touches.
            <para>https://love2d.org/wiki/CompareMode</para>
            </summary>
        </member>
        <member name="F:Love.CompareMode.Less">
            <summary>
            The stencil value of the pixel must be less than the supplied value.
            </summary>
        </member>
        <member name="F:Love.CompareMode.LEqual">
            <summary>
            The stencil value of the pixel must be less than or equal to the supplied value.
            </summary>
        </member>
        <member name="F:Love.CompareMode.Equal">
            <summary>
            The stencil value of the pixel must be equal to the supplied value.
            </summary>
        </member>
        <member name="F:Love.CompareMode.GEqual">
            <summary>
            The stencil value of the pixel must be greater than or equal to the supplied value.
            </summary>
        </member>
        <member name="F:Love.CompareMode.Greater">
            <summary>
            The stencil value of the pixel must be greater than the supplied value.
            </summary>
        </member>
        <member name="F:Love.CompareMode.NotEqual">
            <summary>
            The stencil value of the pixel must not be equal to the supplied value.
            </summary>
        </member>
        <member name="T:Love.Feature">
            <summary>
            https://love2d.org/wiki/GraphicsFeature
            <para>Graphics features that can be checked for with love.graphics.getSupported.</para>
            </summary>
        </member>
        <member name="F:Love.Feature.MultiCanvasFormats">
            <summary>
            Whether multiple Canvases with different formats can be used in the same love.graphics.setCanvas call.
            <para>multicanvasformats is supported on OpenGL 3-capable desktop systems, and OpenGL ES 3-capable mobile devices.</para>
            </summary>
        </member>
        <member name="F:Love.Feature.ClampZero">
            <summary>
            Whether the "clampzero" WrapMode is supported.
            <para>clampzero is supported on all desktop systems, but only some mobile devices. If it's not supported and it's attempted to be set, the "clamp" wrap mode will automatically be used instead.</para>
            </summary>
        </member>
        <member name="F:Love.Feature.Lighten">
            <summary>
            Whether the "lighten" and "darken" BlendModes are supported.
            <para>lighten is supported on all desktop systems, and OpenGL ES 3-capable mobile devices.</para>
            </summary>
        </member>
        <member name="F:Love.Feature.FullNPOT">
            <summary>
            Whether textures with non-power-of-two dimensions can use mipmapping and the 'repeat' WrapMode (Texture:setMipmapFilter).
            </summary>
        </member>
        <member name="F:Love.Feature.PixelShaderHighp">
            <summary>
            Whether pixel shaders can use "highp" 32 bit floating point numbers (as opposed to just 16 bit or lower precision).
            </summary>
        </member>
        <member name="F:Love.Feature.ShaderDerivatives">
            <summary>
            
            </summary>
        </member>
        <member name="F:Love.Feature.GLSL3">
            <summary>
            Whether GLSL 3 Shaders can be used.
            </summary>
        </member>
        <member name="F:Love.Feature.Instancing">
            <summary>
            Whether mesh instancing (love.graphics.drawInstanced) is supported.
            </summary>
        </member>
        <member name="T:Love.AreaSpreadDistribution">
            <summary>
            Type of distribution new particles are drawn from: None, uniform, normal, ellipse, borderellipse, borderrectangle.
            <para>https://love2d.org/wiki/AreaSpreadDistribution</para>
            </summary>
        </member>
        <member name="F:Love.AreaSpreadDistribution.Uniform">
            <summary>
            Uniform distribution.
            </summary>
        </member>
        <member name="F:Love.AreaSpreadDistribution.Normal">
            <summary>
            Normal (gaussian) distribution.
            </summary>
        </member>
        <member name="F:Love.AreaSpreadDistribution.Ellipse">
            <summary>
            Uniform distribution in an ellipse.
            </summary>
        </member>
        <member name="F:Love.AreaSpreadDistribution.BorderEllipse">
            <summary>
            Distribution in an ellipse with particles spawning at the edges of the ellipse.
            </summary>
        </member>
        <member name="F:Love.AreaSpreadDistribution.BorderRectangle">
            <summary>
            Distribution in a rectangle with particles spawning at the edges of the rectangle.
            </summary>
        </member>
        <member name="T:Love.DrawMode">
            <summary>
            Controls whether shapes are drawn as an outline, or filled.
            </summary>
        </member>
        <member name="F:Love.DrawMode.Line">
            <summary>
            Draw outlined shape.
            </summary>
        </member>
        <member name="F:Love.DrawMode.Fill">
            <summary>
            Draw filled shape.
            </summary>
        </member>
        <member name="F:Love.SpriteBatchUsage.Stream">
            <summary>
            The object data will always change between draws.
            </summary>
        </member>
        <member name="F:Love.SpriteBatchUsage.Dynamic">
            <summary>
            The object's data will change occasionally during its lifetime.
            </summary>
        </member>
        <member name="F:Love.SpriteBatchUsage.Static">
            <summary>
            The object will not be modified after initial sprites or vertices are added.
            </summary>
        </member>
        <member name="T:Love.MeshDrawMode">
            <summary>
            https://love2d.org/wiki/MeshDrawMode
            </summary>
        </member>
        <member name="F:Love.MeshDrawMode.Trangles">
            <summary>
            The vertices create a "fan" shape with the first vertex acting as the hub point. Can be easily used to draw simple convex polygons.
            </summary>
        </member>
        <member name="F:Love.MeshDrawMode.Strip">
            <summary>
            The vertices create a series of connected triangles using vertices 1, 2, 3, then 3, 2, 4 (note the order), then 3, 4, 5, and so on.
            </summary>
        </member>
        <member name="F:Love.MeshDrawMode.Fan">
            <summary>
            The vertices create a "fan" shape with the first vertex acting as the hub point. Can be easily used to draw simple convex polygons.
            </summary>
        </member>
        <member name="F:Love.MeshDrawMode.Points">
            <summary>
            The vertices are drawn as unconnected points (see love.graphics.setPointSize.)
            </summary>
        </member>
        <member name="T:Love.PixelFormat">
            <summary>
            Pixel formats for Textures, ImageData, and CompressedImageData.
            https://love2d.org/wiki/PixelFormat
            </summary>
        </member>
        <member name="T:Love.CanvasMipmapMode">
            <summary>
            https://love2d.org/wiki/CanvasMipmapMode
            </summary>
        </member>
        <member name="F:Love.CanvasMipmapMode.None">
            <summary>
            Do not enable mipmap.
            </summary>
        </member>
        <member name="F:Love.CanvasMipmapMode.Manual">
            <summary>
            Let user manually generate mipmap.
            </summary>
        </member>
        <member name="F:Love.CanvasMipmapMode.Auto">
            <summary>
            Automatically generate mipmap.
            </summary>
        </member>
        <member name="T:Love.TextureType">
            <summary>
            Types of textures (2D, cubemap, etc.)
            </summary>
        </member>
        <member name="F:Love.TextureType.TEXTURE_2D">
            <summary>
            Regular 2D texture with width and height.
            </summary>
        </member>
        <member name="F:Love.TextureType.TEXTURE_VOLUME">
            <summary>
            3D texture with width, height, and depth. Requires a custom shader to use. Volume textures can have texture filtering applied along the 3rd axis.
            </summary>
        </member>
        <member name="F:Love.TextureType.TEXTURE_2D_ARRAY">
            <summary>
            Several same-size 2D textures organized into a single object. Similar to a texture atlas / sprite sheet, but avoids sprite bleeding and other issues.
            </summary>
        </member>
        <member name="F:Love.TextureType.TEXTURE_CUBE">
            <summary>
            Cubemap texture with 6 faces. Requires a custom shader (and Shader:send) to use. Sampling from a cube texture in a shader takes a 3D direction vector instead of a texture coordinate.
            </summary>
        </member>
        <member name="M:Love.Love2dGraphicsShaderBoot.createShaderStageCode(System.String,System.String,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="stage">"VERTEX" or "PIXEL"</param>
            <param name="code">input string</param>
            <param name="lang">glsl1 or glsl3</param>
            <param name="gles"></param>
            <param name="glsl1on3"></param>
            <param name="gammacorrect"></param>
            <param name="custom"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Special.GetWin32Handle">
            <summary>
            get win32 HANDLE on windows platform
            </summary>
            <returns></returns>
        </member>
        <member name="T:Love.LoveObject">
            <summary>
            LÖVE 引擎对象
            </summary>
        </member>
        <member name="M:Love.LoveObject.Equals(System.Object)">
            <summary>
            如果两个 LoveObject 指向的非托管对象一样，那么则返回相等
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Love.LoveObject.GetHashCode">
            <summary>
            返回此实例的 IntPtr p 的哈希代码。
            </summary>
            <returns></returns>
        </member>
        <member name="T:Love.Source">
            <summary>
            <para>A Source represents audio you can play back. You can do interesting things with Sources, like set the volume, pitch, and its position relative to the listener. Please note that positional audio only works for mono (i.e. non-stereo) sources.</para>
            </summary>
        </member>
        <member name="M:Love.Source.#ctor">
            <summary>
            disable no-param construct
            </summary>
        </member>
        <member name="M:Love.Source.Clone">
            <summary>
            Creates an identical copy of the Source in the stopped state.
            <para>Static Sources will use significantly less memory and take much less time to be created if <see cref="M:Love.Source.Clone"/> is used to create them instead of Audio.NewSource, so this method should be preferred when making multiple Sources which play the same sound.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Source.Play">
            <summary>
            Plays a source.
            </summary>
            <returns>Whether the Source was able to successfully start playing.</returns>
        </member>
        <member name="M:Love.Source.Stop">
            <summary>
            Stops a source.
            </summary>
        </member>
        <member name="M:Love.Source.Pause">
            <summary>
            Pauses the Source.
            </summary>
        </member>
        <member name="M:Love.Source.SetPitch(System.Single)">
            <summary>
            Sets the pitch of the Source.
            </summary>
            <param name="pitch">Calculated with regard to 1 being the base pitch. Each reduction by 50 percent equals a pitch shift of -12 semitones (one octave reduction). Each doubling equals a pitch shift of 12 semitones (one octave increase). Zero is not a legal value.</param>
        </member>
        <member name="M:Love.Source.GetPitch">
            <summary>
            Gets the current pitch of the Source.
            </summary>
            <returns>The pitch, where 1.0 is normal.</returns>
        </member>
        <member name="M:Love.Source.SetVolume(System.Single)">
            <summary>
            Sets the current volume of the Source.
            </summary>
            <param name="volume">The volume for a Source, where 1.0 is normal volume. Volume cannot be raised above 1.0.</param>
        </member>
        <member name="M:Love.Source.GetVolume">
            <summary>
            Gets the current volume of the Source.
            </summary>
            <returns>The volume of the Source, where 1.0 is normal volume.</returns>
        </member>
        <member name="M:Love.Source.Seek(System.Single,Love.TimeUnit)">
            <summary>
            Sets the currently playing position of the Source.
            </summary>
            <param name="offset">The position to seek to.</param>
            <param name="unit_type">The unit of the position value.</param>
        </member>
        <member name="M:Love.Source.Tell(Love.TimeUnit)">
            <summary>
            Gets the currently playing position of the Source.
            </summary>
            <param name="unit_type">The type of unit for the return value.</param>
            <returns>The currently playing position of the Source.</returns>
        </member>
        <member name="M:Love.Source.GetDuration(Love.TimeUnit)">
            <summary>
            Gets the duration of the Source.
            </summary>
            <param name="unit_type">The time unit for the return value.</param>
            <returns>The duration of the Source, or -1 if it cannot be determined.</returns>
        </member>
        <member name="M:Love.Source.SetPosition(System.Single,System.Single,System.Single)">
            <summary>
            Sets the position of the Source.
            </summary>
            <param name="x">The X position of the Source.</param>
            <param name="y">The Y position of the Source.</param>
            <param name="z">The Z position of the Source.</param>
        </member>
        <member name="M:Love.Source.GetPosition">
            <summary>
            Gets the position of the Source.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Source.SetVelocity(System.Single,System.Single,System.Single)">
            <summary>
            Sets the velocity of the Source.
            </summary>
            <param name="x">The X part of the velocity vector.</param>
            <param name="y">The Y part of the velocity vector.</param>
            <param name="z">The Z part of the velocity vector.</param>
        </member>
        <member name="M:Love.Source.GetVelocity">
            <summary>
            Gets the velocity of the Source.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Source.SetDirection(System.Single,System.Single,System.Single)">
            <summary>
            Sets the direction of the Source.
            </summary>
            <param name="x">The X part of the direction vector.</param>
            <param name="y">The Y part of the direction vector.</param>
            <param name="z">The Z part of the direction vector.</param>
        </member>
        <member name="M:Love.Source.GetDirection">
            <summary>
            Gets the direction of the Source.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Source.SetCone(System.Single,System.Single,System.Single)">
            <summary>
            Sets the Source's directional volume cones.
            </summary>
            <param name="innerAngle">The inner angle from the Source's direction, in radians. The Source will play at normal volume if the listener is inside the cone defined by this angle.</param>
            <param name="outerAngle">The outer angle from the Source's direction, in radians. The Source will play at a volume between the normal and outer volumes, if the listener is in between the cones defined by the inner and outer angles.</param>
            <param name="outerVolume">The Source's volume when the listener is outside both the inner and outer cone angles.</param>
        </member>
        <member name="M:Love.Source.GetCone(System.Single@,System.Single@,System.Single@)">
            <summary>
            Gets the Source's directional volume cones.
            </summary>
            <param name="out_innerAngle"></param>
            <param name="out_outerAngle"></param>
            <param name="out_outerVolume"></param>
        </member>
        <member name="M:Love.Source.SetRelative(System.Boolean)">
            <summary>
            Sets whether the Source's position and direction are relative to the listener.
            <para>By default, all sources are absolute and therefore relative to the origin of love's coordinate system [0, 0, 0]. Only absolute sources are affected by the position of the listener. Please note that positional audio only works for mono (i.e. non-stereo) sources.</para>
            </summary>
            <param name="relative">True to make the position, velocity, direction and cone angles relative to the listener, false to make them absolute.</param>
        </member>
        <member name="M:Love.Source.IsRelative">
            <summary>
            Gets whether the Source's position and direction are relative to the listener.
            </summary>
            <returns>True if the position, velocity, direction and cone angles are relative to the listener, false if they're absolute.</returns>
        </member>
        <member name="M:Love.Source.SetLooping(System.Boolean)">
            <summary>
            Sets whether the Source should loop.
            </summary>
            <param name="looping">True if the source should loop, false otherwise.</param>
        </member>
        <member name="M:Love.Source.IsLooping">
            <summary>
            Returns whether the Source will loop.
            </summary>
            <returns>True if the Source will loop, false otherwise.</returns>
        </member>
        <member name="M:Love.Source.IsPlaying">
            <summary>
            Returns whether the Source is playing.
            </summary>
            <returns>True if the Source is playing, false otherwise.</returns>
        </member>
        <member name="M:Love.Source.SetVolumeLimits(System.Single,System.Single)">
            <summary>
            Sets the volume limits of the source.
            </summary>
            <param name="vmin">The minimum volume.</param>
            <param name="vmax">The maximum volume.</param>
        </member>
        <member name="M:Love.Source.GetVolumeLimits(System.Single@,System.Single@)">
            <summary>
            Returns the volume limits of the source.
            </summary>
            <param name="out_vmin">The minimum volume.</param>
            <param name="out_vmax">The minimum volume.</param>
        </member>
        <member name="M:Love.Source.SetAttenuationDistances(System.Single,System.Single)">
            <summary>
            Sets the reference and maximum attenuation distances of the Source.
            <para>The parameters, combined with the current DistanceModel, affect how the Source's volume attenuates based on distance. Distance attenuation is only applicable to Sources based on mono (rather than stereo) audio.</para>
            </summary>
            <param name="dref">The new reference attenuation distance. If the current <see cref="T:Love.DistanceModel"/> is clamped, this is the minimum attenuation distance.</param>
            <param name="dmax"></param>
        </member>
        <member name="M:Love.Source.GetAttenuationDistances(System.Single@,System.Single@)">
            <summary>
            Gets the reference and maximum attenuation distances of the Source.
            <para>The values, combined with the current DistanceModel, affect how the Source's volume attenuates based on distance from the listener.</para>
            </summary>
            <param name="out_dref">The current reference attenuation distance. If the current <see cref="T:Love.DistanceModel"/> is clamped, this is the minimum distance before the Source is no longer attenuated.</param>
            <param name="out_dmax">The current maximum attenuation distance.</param>
        </member>
        <member name="M:Love.Source.SetRolloff(System.Single)">
            <summary>
            Sets the rolloff factor which affects the strength of the used distance attenuation. see <see cref="T:Love.DistanceModel"/>
            <para>Extended information and detailed formulas can be found in the chapter "3.4. Attenuation By Distance" of OpenAL 1.1 specification(https://www.openal.org/documentation/openal-1.1-specification.pdf).</para>
            </summary>
            <param name="rolloff">The new rolloff factor.</param>
        </member>
        <member name="M:Love.Source.GetRolloff">
            <summary>
            Returns the rolloff factor of the source.
            </summary>
            <returns>The rolloff factor.</returns>
        </member>
        <member name="M:Love.Source.GetChannelCount">
            <summary>
            Gets the number of channels in the Source. Only 1-channel (mono) Sources can use directional and positional effects.
            </summary>
            <returns>1 for mono, 2 for stereo.</returns>
        </member>
        <member name="M:Love.Source.GetSourceType">
            <summary>
            Gets the type of the Source.
            </summary>
            <returns>The type of the source.</returns>
        </member>
        <member name="T:Love.FileData">
            <summary>
            <see cref="T:Love.Data"/> representing the contents of a file.
            </summary>
        </member>
        <member name="M:Love.FileData.#ctor">
            <summary>
            disable no-param construct
            </summary>
        </member>
        <member name="M:Love.FileData.GetFilename">
            <summary>
            Gets the filename of the FileData.
            </summary>
            <returns>The name of the file the FileData represents.</returns>
        </member>
        <member name="M:Love.FileData.GetExtension">
            <summary>
            Gets the extension of the FileData.
            </summary>
            <returns>The extension of the file the FileData represents.</returns>
        </member>
        <member name="T:Love.GlyphData">
            <summary>
            A GlyphData represents a drawable symbol of a font Rasterizer.
            </summary>
        </member>
        <member name="M:Love.GlyphData.#ctor">
            <summary>
            disable no-param construct
            </summary>
        </member>
        <member name="T:Love.Rasterizer">
            <summary>
            A Rasterizer handles font rendering, containing the font data (image or TrueType font) and drawable glyphs.
            </summary>
        </member>
        <member name="M:Love.Rasterizer.#ctor">
            <summary>
            disable no-param construct
            </summary>
        </member>
        <member name="M:Love.Rasterizer.GetHeight">
            <summary>
            Get font height
            </summary>
            <returns></returns>
        </member>
        <member name="T:Love.Canvas">
            <summary>
            <para>A Canvas is used for off-screen rendering. Think of it as an invisible screen that you can draw to, but that will not be visible until you draw it to the actual visible screen. It is also known as "render to texture".</para>
            <para>By drawing things that do not change position often (such as background items) to the Canvas, and then drawing the entire Canvas instead of each item, you can reduce the number of draw operations performed each frame.</para>
            <para>When drawing content to a Canvas using regular alpha blending, the alpha values of the content get multiplied with its RGB values. Therefore the Canvas' pixel colors will have premultiplied alpha once it has been drawn to, so when drawing the Canvas to the screen or to another Canvas you must use premultiplied alpha blending – Graphics.SetBlendMode(BlendMode.Alpha, BlendAlphaMode.PreMultiplied).</para>
            </summary>
        </member>
        <member name="M:Love.Canvas.#ctor">
            <summary>
            disable no-param construct
            </summary>
        </member>
        <member name="M:Love.Canvas.NewImageData">
            <summary>
            Generates ImageData from the contents of the Canvas.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Canvas.NewImageData(System.Int32,System.Int32)">
            <summary>
            Generates ImageData from the contents of the Canvas.
            </summary>
            <param name="slice">The cubemap face index, array index, or depth layer for cubemap, array, or volume type Canvases, respectively. This argument is ignored for regular 2D canvases.</param>
            <param name="mipmap">he mipmap index to use, for Canvases with mipmaps. https://love2d.org/wiki/CanvasMipmapMode </param>
            <returns></returns>
        </member>
        <member name="M:Love.Canvas.NewImageData(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates ImageData from the contents of the Canvas.
            </summary>
            <param name="slice">The cubemap face index, array index, or depth layer for cubemap, array, or volume type Canvases, respectively. This argument is ignored for regular 2D canvases.</param>
            <param name="mipmap">he mipmap index to use, for Canvases with mipmaps. (default is 0) https://love2d.org/wiki/CanvasMipmapMode </param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="w"></param>
            <param name="h"></param>
            <returns></returns>
        </member>
        <member name="M:Love.Canvas.GetFormat">
            <summary>
            Gets the texture format of the Canvas.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Canvas.GetMSAA">
            <summary>
            Gets the number of MSAA samples used when drawing to the Canvas.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Love.Mesh">
            <summary>
            Mesh in Love2d CS is different from  love2d lua.
            </summary>
        </member>
        <member name="M:Love.Mesh.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Mesh.SetVertices(Love.Vertex[],System.Int32)">
            <summary>
            Replaces a range of vertices in the Mesh with new ones. 
            </summary>
            <param name="vertices">each vertex</param>
            <param name="startVertex">The index of the first vertex to replace.</param>
        </member>
        <member name="M:Love.Mesh.GetVertex(System.Int32)">
            TODO
        </member>
        <member name="T:Love.SpriteBatch">
            <summary>
            Using a single image, draw any number of identical copies of the image using a single call to Love.Graphics.Draw(). This can be used, for example, to draw repeating copies of a single background image with high performance.
            <para>A SpriteBatch can be even more useful when the underlying image is a texture atlas (a single image file containing many independent images); by adding Quads to the batch, different sub-images from within the atlas can be drawn.</para>
            </summary>
        </member>
        <member name="M:Love.SpriteBatch.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="T:Love.Texture">
            <summary>
            Superclass for drawable objects which represent a texture. All Textures can be drawn with Quads. This is an abstract type that can't be created directly.
            </summary>
        </member>
        <member name="M:Love.Texture.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Texture.SetMipmapFilter(Love.FilterMode,System.Single)">
            <summary>
            Sets the mipmap filter mode for a Texture.
            <para>Mipmapping(https://en.wikipedia.org/wiki/Mipmap) is useful when drawing a texture at a reduced scale. It can improve performance and reduce aliasing issues.</para>
            <para>The texture must be created with the mipmaps flag enabled for the mipmap filter to have any effect. </para>
            <remarks>On mobile devices (Android and iOS), the sharpness parameter is not supported and will do nothing. You can use a custom Shader instead, and specify the mipmap sharpness in the optional third parameter to the Texel function in the shader (a negative value makes the texture use a more detailed mipmap level.)</remarks>
            </summary>
            <param name="mipmap_type">The filter mode to use in between mipmap levels. "nearest" will often give better performance.</param>
            <param name="sharpness">A positive sharpness value makes the texture use a more detailed mipmap level when drawing, at the expense of performance. A negative value does the reverse.</param>
        </member>
        <member name="M:Love.Texture.GetMipmapFilter(Love.FilterMode@,System.Single@)">
            <summary>
            Gets the mipmap filter mode for a Texture.
            </summary>
            <param name="out_mipmap_type">The filter mode used in between mipmap levels. nil if mipmap filtering is not enabled.</param>
            <param name="out_sharpness">Value used to determine whether the image should use more or less detailed mipmap levels than normal when drawing.</param>
        </member>
        <member name="M:Love.Texture.GetWidth">
            <summary>
            Gets the width of the Texture.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Texture.GetHeight">
            <summary>
            Gets the height of the Texture.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Texture.SetFilter(Love.FilterMode,Love.FilterMode,System.Single)">
            <summary>
            Sets the filter mode of the Texture.
            </summary>
            <param name="filtermin_type">Filter mode to use when minifying the texture (rendering it at a smaller size on-screen than its size in pixels).</param>
            <param name="filtermag_type">Filter mode to use when magnifying the texture (rendering it at a larger size on-screen than its size in pixels).</param>
            <param name="anisotropy">Maximum amount of anisotropic filtering to use.</param>
        </member>
        <member name="M:Love.Texture.GetFilter(Love.FilterMode@,Love.FilterMode@,System.Single@)">
            <summary>
            Gets the filter mode of the Texture.
            </summary>
            <param name="out_filtermin_type">Filter mode to use when minifying the texture (rendering it at a smaller size on-screen than its size in pixels).</param>
            <param name="out_filtermag_type">Filter mode to use when magnifying the texture (rendering it at a smaller size on-screen than its size in pixels).</param>
            <param name="out_anisotropy">Maximum amount of anisotropic filtering used.</param>
        </member>
        <member name="M:Love.Texture.SetWrap(Love.WrapMode,Love.WrapMode)">
            <summary>
            Sets the wrapping properties of a Texture.
            <para>This function sets the way a Texture is repeated when it is drawn with a Quad that is larger than the texture's extent, or when a custom Shader is used which uses texture coordinates outside of [0, 1]. A texture may be clamped or set to repeat in both horizontal and vertical directions.</para>
            <para>Clamped textures appear only once (with the edges of the texture stretching to fill the extent of the Quad), whereas repeated ones repeat as many times as there is room in the Quad.</para>
            </summary>
            <param name="wraphoriz_type">Horizontal wrapping mode of the texture.</param>
            <param name="wrapvert_type">Vertical wrapping mode of the texture.</param>
        </member>
        <member name="M:Love.Texture.GetWrap(Love.WrapMode@,Love.WrapMode@)">
            <summary>
            Gets the wrapping properties of a Texture.
            <para>This function returns the currently set horizontal and vertical wrapping modes for the texture.</para>
            </summary>
            <param name="out_wraphoriz_type">Horizontal wrapping mode of the texture.</param>
            <param name="out_wrapvert_type">Vertical wrapping mode of the texture.</param>
        </member>
        <member name="M:Love.ImageDataBase.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.CompressedImageData.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Cursor.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Cursor.GetType">
            <summary>
            Gets the type of the Cursor.
            </summary>
            <returns>The type of the Cursor.</returns>
        </member>
        <member name="M:Love.Decoder.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="F:Love.Decoder.DEFAULT_BUFFER_SIZE">
            <summary>
            Indicates how many bytes of raw data should be generated at each call to Decode.
            </summary>
        </member>
        <member name="F:Love.Decoder.DEFAULT_SAMPLE_RATE">
            <summary>
            Indicates the quality of the sound.
            </summary>
        </member>
        <member name="F:Love.Decoder.DEFAULT_CHANNELS">
            <summary>
            Default is stereo.
            </summary>
        </member>
        <member name="F:Love.Decoder.DEFAULT_BIT_DEPTH">
            <summary>
            16 bit audio is the default.
            </summary>
        </member>
        <member name="M:Love.SoundData.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.VideoStream.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.BezierCurve.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.RandomGenerator.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Data.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Data.GetSize">
            <summary>
            Gets the Data's size in bytes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Data.GetPointer">
            <summary>
            Gets a pointer to the Data.
            <para>Use at your own risk. Directly reading from and writing to the raw memory owned by the Data will bypass any safety checks and thread-safety the Data might normally have.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.Data.GetBytes">
            <summary>
            Get file data full byte[]
            <para>This function can be slow if it is called repeatedly, such as from <see cref="M:Love.Scene.Update(System.Single)"/> or <see cref="M:Love.Scene.Draw"/> . If you need to use a specific resource often, create it once and store it somewhere it can be reused!</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Love.TrueTypeRasterizer.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Drawable.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.DroppedFile.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.Stream.#ctor">
            <summary>
            disable construct
            </summary>
        </member>
        <member name="M:Love.ColoredString.Create(System.String,Love.Vector4)">
            <summary>
            Create ColoredString form text and color
            </summary>
            <param name="text"></param>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="M:Love.ColoredString.Create(System.String,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Create ColoredString form text and color
            </summary>
            <param name="text"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:Love.ColoredStringArray.Create(System.String)">
            <summary>
            Create white Color text
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
    </members>
</doc>
