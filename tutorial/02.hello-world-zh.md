> 感谢、本章由 [fanbal@gitee](https://gitee.com/fanbal)  :smile: [完成](https://gitee.com/endlesstravel/love2dCS/issues/I3R2L4)

# Hello, World
让我们从头开始为我们的第一个游戏创建一个Hello World应用。

## 最简单的例子
让我们先来看看这个极其微缩的应用，这个应用可以将文本"Hello, World"绘制在屏幕上。

```C#
using Love;
public class Program : Scene
{
    static void Main(string[] args)
    {
        Boot.Init();
        Boot.Run(new Program());
    }

    public override void Draw()
    {
        Graphics.Print("Hello, World!", 400, 300);
    }
}
```

在这里，我们一般需要通过传递一个`Program`类的实例对Love2DCS进行初始化，其中`Program`类派生自`Scene`类。之后我们覆写了`Draw`方法用于绘制单行文本。超简单对吧！

## 核心回调函数

在Love2DCS中，API中最重要的部分是以下这些回调函数（Callback）：

+ `Love.Scene.Load`: 在这块回调函数中你需要为你的游戏进行最初的配置，如载入资源，配置一些数据等。
+ `Love.Scene.Update`: 逐帧地管理、控制和更新你的游戏数据。
+ `Love.Scene.Draw`:  在屏幕上进行游戏状态的渲染。

原则上来说，你只需要继承`Scene`类体并且覆写它的`Load`、`Update`以及`Draw`方法，这些将是你实现一个完整游戏方方面面的最基础前提。

其实这里还有更多实用的可覆写方法，但是这三个是所有程序的基础。

## 动画样例


让我们来看看一个更复杂的例子。毕竟我们在制作游戏，所以我们希望加入移动，让画面看起来更加有趣生动。要知道死气的静态文本可非我们所愿！

```C#
using Love;

namespace Game
{
    public class Program : Scene
    {
        static void Main(string[] args)
        {
            // 初始化Love2DCS框架。
            Boot.Init();
            Boot.Run(new Program());
        }

        // ----------------------------------------------------------------

        private float textX, textY;
        private string text = "Hello, World!";

        private float timer;
        private float offsetY;

        // This is the ideal place to load assets (images, audio, text), set up defaults, and initialize stuff.
        // This is only ever called once.
        
        // 这是加载资源（图像、音频、文本）、设置默认值和初始化内容最合适的地方。
        // 它会触发一次。
        public override void Load()
        {
            // 如果您不为您的游戏加载字体，Love2DCS会自发加载默认字体。
            var defaultFont = Graphics.GetFont();

            // 计算字符串 "Hello, World!" 的二维参数。
            var textWidth = defaultFont.GetWidth(text);
            var textHeight = defaultFont.GetHeight();

            // 通过下面两行代码，我们能将这个文字放在屏幕画布中央。
            textX = Graphics.GetWidth() / 2 - textWidth / 2;
            textY = Graphics.GetHeight() / 2 - textHeight / 2;
        }


        // 这通常是你编写更新游戏状态、移动角色、计算伤害等业务的地方。
        // 在这里，参数 "dt" 代表上一帧到这一帧之间的时间间隔（单位为秒）。
        // 在实现一些与帧率无关的模拟需求实现时，这个参数极为实用。
        public override void Update(float dt)
        {
            // 通过按下 Escape 键（Esc键，位于键盘左上角），就可以关闭游戏程序。
            if (Keyboard.IsPressed(KeyConstant.Escape))
            {
                Event.Quit();
            }

            // 让我们将时间推进一点，不过速度会比真实世界快一些。timer字段在上方有声明。
            timer += dt * 3.0f;

            // 实现25px幅度的“偏移震荡”。
            offsetY = Mathf.Sin(timer) * 25.0f;
        }

        // 您的所有绘制均位于这个覆写模块。
        public override void Draw()
        {
            // 好黄啊。
            Graphics.SetColor(Color.Yellow);

            // 在中心绘制文本，使用offset字段让它有震荡的效果。
            Graphics.Print(text, textX, textY + offsetY);
        }
    }
}
```
当你开始运行你的应用后，你应该能够看到一个黄色的文本在屏幕中心附近上下反复运动。
